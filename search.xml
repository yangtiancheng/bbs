<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[npm切换国内源]]></title>
    <url>%2Fbbs.github.io%2Fnpm%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90%2F</url>
    <content type="text"><![CDATA[切换国内源npm install -g cnpm –registry=https://registry.npm.taobao.org cnpm install hexo-cli -g]]></content>
      <tags>
        <tag>linux</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PEP8必须学习]]></title>
    <url>%2Fbbs.github.io%2FPEP8%E5%BF%85%E9%A1%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[URL-ChineseURL-English 这些开发规范还是很重要的，必读]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postgresql10持续学习(ing)]]></title>
    <url>%2Fbbs.github.io%2FPostgresql10%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0-ing%2F</url>
    <content type="text"><![CDATA[视图 视图是为了避免每次查询都要敲打sql而出现的替代物，它就像一张表，可以存储多个变之间的结构和数据关系。12345-- 学生选课查询create view myView AS select p.name,p.age,c.name from people p,course c where p.id = c.p_id 以后我想查询数据，我只需要select * from myView;就能实现我的整个查询。 外键 可以约束表的插入数据的完整性 事务 事务最重要的一点是它将多个步骤捆绑成了一个单一的、要么全完成要么全不完成的操作 一个事务被数据库系统完成并认可，它就被永久地记录下来且即便其后发生崩溃也不会被丢失 当多个事务并发运行时，每一个都不能看到其他事务未完成的修改 一组被BEGIN和COMMIT包围的语句也被称为一个事务块 保存回滚点 回滚点前的数据依旧存在 回滚点到rollback区间的操作不记录savepoint 回滚点名称rollback to 回滚点名称1234567891011BEGIN;UPDATE accounts SET balance = balance - 100.00WHERE name = 'Alice';SAVEPOINT my_savepoint;UPDATE accounts SET balance = balance + 100.00WHERE name = 'Bob';-- oops ... forget that and use Wally's accountROLLBACK TO my_savepoint;UPDATE accounts SET balance = balance + 100.00WHERE name = 'Wally';COMMIT; 窗口函数 窗口函数主要是用聚集函数的，但是需要部分聚集，相同聚集字段记录放一起进行聚集计算OVER (ORDER BY 字段名 ORDER BY 字段名) 是窗口函数的定义1SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary; 继承123456789CREATE TABLE cities (name text,population real,altitude int -- (in ft));CREATE TABLE capitals (state char(2)) INHERITS (cities); 123SELECT name, altitudeFROM ONLY citiesWHERE altitude &gt; 500; ONLY用于指示查询只在cities表上进行而不会涉及到继承层次中位于cities之下的其他表]]></content>
      <tags>
        <tag>Postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo12-启动持续分析(ing)]]></title>
    <url>%2Fbbs.github.io%2FOdoo12-%E5%90%AF%E5%8A%A8%E6%8C%81%E7%BB%AD%E5%88%86%E6%9E%90-ing%2F</url>
    <content type="text"><![CDATA[sys.argv:第一个参数是执行的文件全路径，后面的参数是执行文件时的参数 OptionContainer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152抽象类类属性： standard_option_list - 一个列表，用于列出公共的选项，一般在继承的子类中实现 实例属性： option_list： 选项对象列表 _short_opt：&#123;string:Opthon&#125; 简写 _long_opt：&#123;string:Opthon&#125; 全称 defaults：&#123;string:any&#125; 其他默认指令映射方法： __init__: self._create_option_list() self.option_class = option_class# 选项类 self.set_conflict_handler(conflict_handler)# 冲突类 self.set_description(description) # 描述 _create_option_mappings: # 初始化三个实例属性 self._short_opt = &#123;&#125; # single letter -&gt; Option instance self._long_opt = &#123;&#125; # long option -&gt; Option instance self.defaults = &#123;&#125; # maps option dest -&gt; default value _share_option_mappings： # 设置三个实例属性 set_conflict_handler： # 设置冲突处理 参数： handler - error/resolve conflict_handler = handler set_description： # 设置描述 get_description： # 获取描述 def destroy(self): # 三个实例参数销毁 &quot;&quot;&quot;see OptionParser.destroy().&quot;&quot;&quot; del self._short_opt del self._long_opt del self.defaults _check_conflict： 验证当前选项是否已经存在 add_option： 单个选项添加 add_options： 参数： option_list 批量选项添加 OptionParserodoo.tools.config.parse_config(args)是什么作用？ odoo-bin import odoo 包引入，参数初始化 odoo.cli.main()启动服务 command.py args - 拿到对应的启动参数 commands - 可调用函数集合 o - 实例化Server类 o.run(args) - 启动服务 cli/server.py/main(args) cli/server.py(只提及主要部分) check_root_user() 检查当前操作机器用户不能为root 限制权限 odoo.tools.config.parse_config(args)# 加载–config文件内容到全局变量 或者创建一个./config文件 check_postgres_user()#post的用户不能是postgres report_configuration()# 打印配置信息 config 就是当前加载过config文件 系统的配置参数实例 config - pidfile文件存在的话，如果args参数第二个为evented，打开文件存储主线程相关 odoo.service.server.start启动wsgi load_server_wide_modules 加载服务器预支模块base、web initialize_sys_path()初始化配置的系统路径addons_path 挂载钩子 sys.meta_path 和 hooked=True]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python统计文件行数]]></title>
    <url>%2Fbbs.github.io%2FPython%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[basedirs = [‘/Users/tc/code/odoo8/hrp’]filelists = [] 指定想要统计的文件类型whitelist = [‘xml’, ‘py’, ‘js’, ‘css’] 遍历文件, 递归遍历文件夹中的所有12345678910111213def getFile(basedir): global filelists local_filelists = [] for parent,dirnames,filenames in os.walk(basedir): #for dirname in dirnames: # getFile(os.path.join(parent,dirname)) #递归 for filename in filenames: ext = filename.split('.')[-1] #只统计指定的文件类型，略过一些log和cache文件 if ext in whitelist: local_filelists.append(os.path.join(parent,filename)) filelists.append(os.path.join(parent,filename)) return local_filelists 统计一个文件的行数def countLine(fname): count = 0 for file_line in open(fname).xreadlines(): if file_line != ‘’ and file_line != ‘\n’: #过滤掉空行 count += 1 return countif name == ‘main‘ : startTime = time.clock() all_line = 0 for basedir in basedirs: local_filelists = getFile(basedir) totalline = 0 for filelist in local_filelists: totalline = totalline + countLine(filelist) all_line += totalline print str(basedir.split(“/“)[-1])+’,’,totalline print ‘ =&gt; ALL LINES:’+str(all_line)]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-Xmlrpc]]></title>
    <url>%2Fbbs.github.io%2FOdoo-Xmlrpc%2F</url>
    <content type="text"><![CDATA[XMLRPC 看例子1234外部调用url:http://localhost:8069/xmlrpc/2/objectmethod:postapplication/xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--XML请求报文结构--&gt;&lt;methodCall&gt; &lt;!-- used to call methods of odoo models --&gt; &lt;methodName&gt;execute&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;!--数据库名称--&gt; &lt;value&gt;&lt;string&gt;zocx919&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;!--登录用户ID--&gt; &lt;value&gt;&lt;int&gt;用户ID&lt;/int&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;!--用户登录密码--&gt; &lt;value&gt; &lt;string&gt;zochrp&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;!--调用方法存在的模型--&gt; &lt;value&gt; &lt;string&gt;account.asset.asset&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;!--调用方法的名称--&gt; &lt;value&gt; &lt;string&gt;get_datas&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;!--传入方法的参数--&gt; &lt;param&gt; &lt;array&gt; &lt;struct&gt; &lt;member&gt; &lt;!--Key 不用写string 否则报错--&gt; &lt;name&gt;name&lt;/name&gt; &lt;!--Value--&gt; &lt;value&gt;&lt;string&gt;LiMing&lt;/string&gt;&lt;/value&gt; &lt;/member&gt; &lt;/struct&gt; &lt;value&gt;&lt;int&gt;1&lt;/int&gt;&lt;/value&gt; &lt;/array&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; 123456789# 响应方法class HrpZocAccountAssetAsset(models.Model): _inherit = "account.asset.asset" @api.model def get_datas(self, vals): print 'ok............' return vals # 返回值 要拼接成 字典 类型， xmlrpc自动解析返回xml格式响应报文 分析1、调用的数据中记得必须使用的是object2、XML请求报文中 array标签类似于python中的列表，struct标签类似于python中的字典，struct结构中只能出现格式: 1234&lt;member&gt; &lt;name&gt;xxx&lt;/name&gt; &lt;value&gt;xxx&lt;/value&gt;&lt;/member&gt; 3、python代码中需要定义特定的接收方法，并且返回一个数据字典 其他暂无]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-Jsonrpc]]></title>
    <url>%2Fbbs.github.io%2FOdoo-Jsonrpc%2F</url>
    <content type="text"><![CDATA[JSONRPC 看例子1234外部调用url:http://localhost:8069/jsonrpcmethod:postapplication/json 12345678910111213&#123; "jsonrpc": "2.0", "method": "call", "params": &#123; "service": "object", "method": "execute", "args": ["数据库名称", 登录用户ID, "登录用户密码", "模型", "方法", [ '参数及合' ] ] &#125;&#125; 123456789# 响应方法class HrpZocAccountAssetAsset(models.Model): _inherit = "account.asset.asset" @api.model def get_datas(self, vals): print 'ok............' return vals # 返回值 要拼接成 字典 类型响应报文]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-QWeb]]></title>
    <url>%2Fbbs.github.io%2FOdoo-QWeb%2F</url>
    <content type="text"><![CDATA[Base Template /static/src/xml/*.xml 定义模板。 openerp.py的qweb中注册*.xml文件 JS加载模板(两种) QWeb.render(模板名称) template: “模板名称” JS调用模板传参(两种) QWeb.render(模板名称,参数字典) template接收显示\ template: “模板名称” 通过init方法初始化参数,通过this传递(注意parent参数和继承_super方法必须使用)1234init: function(parent) &#123; this._super(parent); this.name = "Mordecai"; &#125;, template接收显示\]]></content>
      <tags>
        <tag>Odoo-Qweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-报表]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E6%8A%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[pdf报表PDF报表结构 一个XML数据配置文件 一个py文件 Odoo原生的报表通过HTML或者QWeb定义，可以通过Qweb控制流工具，使用wkhtmltopdf来注册pdf。定义一个报表的主要需要定义1.报表 2.报表模板 3.可以个性化格式 4.可以客户化class来为报表的数据服务 Report 报表都需要定义一个 report_action： 可以通过一个标签来定义 report_action.格式定义： id - 是report_action的外部ID(ir_model_data可查) name(必输) - 数据库中的report_name 用于对应报表模板的外部ID file - 数据库中的report_file 与name相同 string - PDF报表名称 action的下拉名称 model(必输) - 报表放那个model的界面上 report_type(必输) - 报表类型 目前我们认为它只有两种打印PDF的qweb-pdf、和打印HTML的qweb-html. report_name - 报表名称 输出报表的名字 groups - 组权限控制 哪个对应的用户组能够触发报表操作 attachment_use - bool(true/false) 如果设置成True则会将打印的报表以附件attachment的形式存储在系统的附件系统中，用于一次使用，需要测试。 attachment - python逻辑赋值表达式，用来定义附件存储的文件名称 可使用一定的逻辑判断赋值。 paperformat - 默认定义为公司下的纸张格式 如果有特殊需要可以自定义纸张格式。 1234567891011&lt;report id="account_invoices" model="account.invoice" string="Invoices" report_type="qweb-pdf" name="account.report_invoice" file="account.report_invoice" attachment_use="True" attachment="(object.state in ('open','paid')) and ('INV'+(object.number or '').replace('/','')+'.pdf')"/&gt; Report Template 报表模板中call外部布局样式，它将添加默认的报表头和报表尾。PDF报表体江北包含在标签中，template的外部id必须符合报表定义规则，从Qweb模板中，能够通过docs访问对象包含的所有字段。 报表中有一些特定的变量: docs - 当前报表的记录集合(数据) doc_ids - 当前报表的记录集合的ids列表 doc_model - docs包含的数据记录来源model time - 从python标准库中引用的time对象 user - 打印报表的用户 res_company - 当前打印报表用户对应公司 如果需要访问其他模型的记录集，可以关注后续的客户话报表。 Translatable Templates(可翻译的模板)如果需要根据业务伙伴的语言来打印对应语言格式的报表，需要定义两个模板。 主报表模板 可翻译的文件 可以在主报表模板中加入t-lang属性设置语言来直接调用翻译文件，如果需要对使用的字段等进行翻译，可以对字段附属的对象传入相应的context参数，使对象变的可翻译。1如果没有想要翻译，最好不写，因为写入会重读记录，影响打印效率 1234567891011121314151617181920212223242526&lt;!-- Main template --&gt;&lt;template id="report_saleorder"&gt; &lt;t t-call="web.html_container"&gt; &lt;t t-foreach="docs" t-as="doc"&gt; &lt;t t-call="sale.report_saleorder_document" t-lang="doc.partner_id.lang"/&gt; &lt;/t&gt; &lt;/t&gt;&lt;/template&gt;&lt;!-- Translatable template --&gt;&lt;template id="report_saleorder_document"&gt; &lt;!-- Re-browse of the record with the partner lang --&gt; &lt;t t-set="doc" t-value="doc.with_context(&#123;'lang':doc.partner_id.lang&#125;)" /&gt; &lt;t t-call="web.external_layout"&gt; &lt;div class="page"&gt; &lt;div class="oe_structure"/&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6"&gt; &lt;strong t-if="doc.partner_shipping_id == doc.partner_invoice_id"&gt;Invoice and shipping address:&lt;/strong&gt; &lt;strong t-if="doc.partner_shipping_id != doc.partner_invoice_id"&gt;Invoice address:&lt;/strong&gt; &lt;div t-field="doc.partner_invoice_id" t-options="&#123;&amp;quot;no_marker&amp;quot;: True&#125;"/&gt; &lt;...&gt; &lt;div class="oe_structure"/&gt; &lt;/div&gt; &lt;/t&gt;&lt;/template&gt; 解释一下:主报表模板调用附加context属性t-lang为doc.partner_id.lang 的翻译模板，这样就会被对应的语言渲染。这样的话，报表就会打印成对应业务伙伴语言的报表。如果只需要转换报表体内容而不动报表头/尾部分，可以：1&lt;t t-call="web.external_layout" t-lang="en_US"&gt; Barcodes(条形码)可以很方便的借助Qweb的语法将条形码嵌入到模板中1&lt;img t-att-src="'/report/barcode/QR/%s' % 'My text in qr code'"/&gt; 可以传递一些参数：12&lt;img t-att-src="'/report/barcode/? type=%s&amp;value=%s&amp;width=%s&amp;height=%s'%('QR', 'text', 200, 200)"/&gt; Useful Remarks(有效的语法) Report Template可以使用Twitter Bootstrap 和 FontAwesome类来渲染。 本地CSS可以在Template中使用。 可以通过继承主报表样式来插入到我们的css中。 123456789&lt;template id="report_saleorder_style" inherit_id="report.style"&gt; &lt;xpath expr="."&gt; &lt;t&gt; .example-css-class &#123; background-color: red; &#125; &lt;/t&gt; &lt;/xpath&gt;&lt;/template&gt; Paper Format(纸张格式)报表格式是report.paperformat对象的记录，它们经常包括如下几个参数: name(必输) - 可标识样板格式的简要名称 description - 对样板简短的介绍 format - 预定义格式A0-A9 B0-B9 Legal Letter Tabloid… 默认是A4，如果定义了这个参数将无法使用个性化的格式。 dpi - 输出的DPI 默认为90 margin_top, margin_bottom, margin_left, margin_right - 边距大小默认单位mm page_height , page_width - 页面尺寸 默认单位mm orientation - Landscape 或者 Portrait header_line - 布尔值 是否显示头行 header_spacing - 头空间 默认单位mm 123456789101112131415&lt;record id="paperformat_frenchcheck" model="report.paperformat"&gt; &lt;field name="name"&gt;French Bank Check&lt;/field&gt; &lt;field name="default" eval="True"/&gt; &lt;field name="format"&gt;custom&lt;/field&gt; &lt;field name="page_height"&gt;80&lt;/field&gt; &lt;field name="page_width"&gt;175&lt;/field&gt; &lt;field name="orientation"&gt;Portrait&lt;/field&gt; &lt;field name="margin_top"&gt;3&lt;/field&gt; &lt;field name="margin_bottom"&gt;3&lt;/field&gt; &lt;field name="margin_left"&gt;3&lt;/field&gt; &lt;field name="margin_right"&gt;3&lt;/field&gt; &lt;field name="header_line" eval="False"/&gt; &lt;field name="header_spacing"&gt;3&lt;/field&gt; &lt;field name="dpi"&gt;80&lt;/field&gt;&lt;/record&gt; 客户化报表报表model有一个get_html方法，就是通过report.{module.report_name}来寻找客户化报表model，如果找到的话，将使用找到的这个类来调用Qweb引擎,否则就调用默认方法。如果希望客户化一个包含了各种项的报表模板，就可以定义这个model，重写render_html方法，并且在docargs列表中传递数据。 报表都可以在web页面上显示可以通过例如:http:///report/html/sale.report_saleorder/38http:///report/pdf/sale.report_saleorder/38如上方式访问html/pdf的报表 Odoo11 PDF报表实例流程1.创建一个ir.actions.report对象12345678&lt;report string="界面打印下拉框处显示的文字" id="ir_model_data表中创建的数据记录name 其实就是外部id①" model="报表绑定的model 在哪个界面上显示" report_type="报表类别/qweb-pdf" name="hrp_asset.report_asset_transfer_application" file="hrp_asset.report_asset_transfer_application"/&gt; XML文件中 首先介绍一下XML文件中的基础格式: 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;openerp&gt; &lt;data&gt; &lt;/data&gt;&lt;/openerp&gt; 初始化一个report数据项: 12345678&lt;report string="界面打印下拉框处显示的文字" id="ir_model_data表中创建的数据记录name 其实就是外部id①" model="报表绑定的model 在哪个界面上显示" report_type="报表类别/qweb-pdf" name="hrp_asset.report_asset_transfer_application" file="hrp_asset.report_asset_transfer_application"/&gt; 对report项绑定一个数据模板，paperformat_id来自于report.paperformat: 123&lt;record id="ir_model_data表中创建的数据记录name 其实就是外部id①" model="ir.actions.report.xml"&gt; &lt;field name="paperformat_id" ref="hrp_base.paperformat_horizontal_A4"/&gt;&lt;/record&gt; 注:这里的paperformat可以自行定义样式]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-Excel下载]]></title>
    <url>%2Fbbs.github.io%2FExcel%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[excel下载结构class inherit_report_xls(report_xls)①class inherit_rml_parse(report_sxw.rml_parse)② 第一个python类class继承report_xls,用于控制界面样式调整，主要是重写继承类report_xls中的generate_xls_report方法。继承report_xls类的class初始化。 第二个python类class用于基础数据获取与传递功能。就是文中的_p 一个odoo类class用于使用odoo的ORM或方法定义获取对应的数据集合。 12另外:大多数报表都有相应的弹出界面选择功能，对应的可以使用这个class去定义一些弹出框的选择字段，用作筛选条件。总之，这个class就是用于各种数据逻辑处理的模型。 实例化第一个report_xls类，用于注册使用。inherit_report_xls(‘report.report_name’③,’报表定义的model’④,’inherit_rml_parse’⑤) 一个XML,用于定义form弹窗相关的Acion、Form、Report与模型进行绑定 流程： 123456789101112实现流程： 创建report_xls的继承类和report_sxw.rml_parse的继承类。 实例化report_xls继承类 创建odoo的class定义字段、写各种方法(例如获取数据下载报表方法print_report，打开报表选择页面的action方法等)。 创建XML来个性化弹出框与选择条件，定义一个print_report按钮，定义一个连接数据对象。 操作流程: 点击报表菜单 - 弹出一个form界面(可能有参数选择) - 完成后点击打印按钮(print_report) - 报表打印 另外:12345return &#123; &apos;type&apos;: &apos;ir.actions.report.xml&apos;, &apos;report_name&apos;: &apos;nov.account.journal.xls&apos;, &apos;datas&apos;: datas, &apos;context&apos;:self.env.context&#125; 直接return调用report_name的报表，有时候回使用一下context传点个性化的参数。 12345678&lt;record id="action_import_move_line_details_xls" model="ir.actions.report.xml"&gt; &lt;field name="name"&gt;Import Move Line Details&lt;/field&gt; &lt;field name="model"&gt;hrp.account.gl.account.move&lt;/field&gt; &lt;field name="type"&gt;ir.actions.report.xml&lt;/field&gt; &lt;field name="report_name"&gt;import.move.line.details.xls&lt;/field&gt; &lt;field name="report_type"&gt;xls&lt;/field&gt; &lt;field name="auto" eval="False"/&gt; &lt;/record&gt; 重要的是model，report_name,report_type： model目前我是默认写的objects挂载的模型，和注册中的model名称相同。(后续了解ir.act.report.xml看看model是用来干啥的) report_name:python代码中return调用的xls，其实就是ir.act.report.xml的唯一属性。 report_type:是报表支持的类型，qweb-pdf、qweb-html、pdf、xls、xlsx等。 1234&apos;name&apos;: &#123; &apos;header&apos;: [1, 25, &apos;text&apos;, _render(&quot;_(&apos;Name&apos;)&quot;)], &apos;lines&apos;: [1, 0, &apos;text&apos;, _render(&quot;line[&apos;name&apos;] or &apos;&apos;&quot;)], &apos;totals&apos;: [1, 0, &apos;text&apos;, None]&#125;, ’text’那个位置是用来判断初始化的 ‘’ 123import_move_line_details_xls(&apos;report.import.move.line.details.xls&apos;, &apos;hrp.account.gl.account.move&apos;, parser=import_move_line_details_xls_parser) 格式：report_xls继承类(‘xls名称’,’objects挂载模型’,’parser对象’)objects挂载模型的意思是，我们excel的数据取值是通过对应的记录来取值的，这里必须选择取数逻辑的model.我们可以发现它直接定位到了我们打印的单据数据，当然这是在form上或者通过form的一个按钮打开一个Transation的model来打印报表的，如果是那种放在’更多’中的批量数据打印，我们还需要相应的做一些context的处理。 逐步理解中…]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo8-JS小记]]></title>
    <url>%2Fbbs.github.io%2FOdoo8-JS%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JS - 基础入门理解 定义ir.action.client 带tag 与绑定的菜单对象123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;openerp&gt; &lt;data&gt; &lt;record id="widget_menu_action" model="ir.actions.client"&gt; &lt;field name="name"&gt;Widget Menu Action&lt;/field&gt; &lt;field name="tag"&gt;tps_widget.widget_menu&lt;/field&gt; &lt;/record&gt; &lt;menuitem id="tps_widget_top_menu" name="Widget Top Menu" sequence="10"/&gt; &lt;menuitem id="tps_widget_sub_menu" name="Widget Sub Menu" parent="tps_widget_top_menu" sequence="10"/&gt; &lt;menuitem id="tps_widget_func_menu" name="Widget Func Menu" parent="tps_widget_sub_menu" action="widget_menu_action" sequence="10"/&gt; &lt;/data&gt;&lt;/openerp&gt; 定义一个js文件 - extend_widget.js 包含content： 12345678910111213openerp.tps_widget = function (instance, local) &#123; var _t = instance.web._t, _lt = instance.web._lt; var QWeb = instance.web.qweb; local.MyWidget = instance.Widget.extend(&#123; start: function () &#123; console.log("load Mywidget.") &#125; &#125;); //第一个参数是tag 第二个参数是widget的完整地址 instance.web.client_actions.add('tps_widget.widget_menu', 'instance.MyWidget');&#125; 引入js文件，定义一个xmlviews/xxx_template.xml 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;openerp&gt; &lt;data&gt; &lt;template id="assets_backend" name="tps_widget" inherit_id="web.assets_backend"&gt; &lt;xpath expr="." position="inside"&gt; &lt;script type="text/javascript" src="/tps_widget/static/js/extend_widget.js"&gt;&lt;/script&gt; &lt;/xpath&gt; &lt;/template&gt; &lt;/data&gt;&lt;/openerp&gt; 注意这里暂时没有py文件，但是xml文件需要在openerp.py中注册[定义菜单的xml 和 引入js的xml]。 用法 this this.$el ob.appendTo(this.$el) this.getParent().$el this.getChildren()[0].$el JS - 挂件o2m_uniqueo2m中的主数据字段，每张单据只能选一次，唯一性处理。 many2many_tagm2m单据数据排列组合不可重复]]></content>
      <tags>
        <tag>Odoo-JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本操作指令笔记]]></title>
    <url>%2Fbbs.github.io%2Fgit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本操作基本命令git clone url git checkout -b T1 git checkout T1git checkout . git branch git branch -D T1 git branch -m T1 git status git diff git add . git commit [-m ‘message’] git push origin T1 git fetch origin T1:T1 git merge –no-ff master-branch git reset –mixed HEAD^ git commit –amend 可以对上一次的提交做修改 git clean -df 代码冲突解决流程 git checkout test git pull origin test git checkout 任务分支 git checkout -b 任务分支-1 git merge –no-ff test 代码中解决冲突 git add . git commit git push origin 任务分支-1 gitlab上合并 任务分支-1 到 test]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-翻译]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[ir_translation简章[字段]langsrcnameres_idmodulestatecommentsvaluetype 几种翻译的加载方式普通按钮翻译 直接加载翻译 注:(XML上的按钮翻译旧源不认识下划线_) 报表翻译report:report_name:0 直接加载翻译 菜单翻译重启 - 升级 - 加载翻译 字段翻译直接加载翻译 code翻译直接加载翻译 module信息翻译手动删除所有翻译，重新加载翻译 重写源码的字段翻译直接在继承的小模块i18n中重写 module:写原来的或但钱模块的都可以 最后在数据库中会被转换成小模块的 例如:hrp_account翻译的显示值使用的是id最大的那一个匹配值1234#. module: account#: selection:account.invoice,state:0msgid &quot;Open&quot;msgstr &quot;已审批&quot;]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-XML]]></title>
    <url>%2Fbbs.github.io%2FOdoo-XML%2F</url>
    <content type="text"><![CDATA[xmldata文件初始化中的知识点1.结构123456789&lt;openerp&gt; &lt;data&gt; &lt;record&gt; &lt;filed&gt;&lt;/filed&gt; &lt;/record&gt; &lt;/data&gt; &lt;data&gt;...&lt;/data&gt; ...&lt;/openerp&gt; 属性篇attrs(公共属性) invisible:影藏组件。 required:组件必须有值。 readonly:组件只读不可编辑(onchange过来的值不会被保存，需要在create/write方法中加入到vals中，或者开发个性化readonly存储挂件，例如:readonly_by_pass)。 如果后面的条件是类似domain形式的，那么[(A,’OP’,B)]中，A是一个可选的字段，但是这个字段不能像py中的domain，它不能使用A.b这样的字段引用关系。所以如果我们需要把这样的A.b字段在我们的模型中定义一个related字段，并把它放在xml中，这就是我们所谓的辅助字段。&gt; noupdate - forcecreate noupdate - 属于data的标签属性 forcecreate - 属于record的标签属性123456789作用： noupdate主要用于data块里的record记录初始化，这些记录都会有一个ExtendID，也就是record上所谓的id,在ir_module_data上唯一。 noupdate的主要功能是初始化一遍数据，如果之后对XML数据定义修改了，再升级，这些数值是不会变化的，依旧保持第一次上来的样子。 但是如果你在界面删除了初始化的数据，那么下次升级模块，这些数据就会以修改后的XML数据为基础创建。 如果只想数据第一次初始化进来，以后不改变，并且就算被删掉后，希望升级后也不要出现，那么就给对应的record记录上， 写forcecreate=&apos;false&apos;,这样就能保证模块安装初始化上来的数据，不会被任何情况修改更新，删除后不再创建。 forcecreate必须绑定在noupdate中才生效,noupdate保持已有数据不更新，forcecreate保证数据删除，升级不创建。如果删除了noupdate块中data文件初始化的数据记录，然后你重新更新它不重置，你可以看一下ir_module_data表，对应的data块外部id记录中，noupdate=True,把那条记录删除再升级就出来了。 options(m2o关系字段属性) no_create_edit:关系字段不允许在当前界面创建这个字段对应的模型记录。 no_create:不允许直接在当前界面创建字段对应的模型记录(从代码中看no_create_edit和no_create逻辑一样)。 no_open:不允许打开关系字段后面对应的单据。 注意：最好用no_open:True/False，不要过度使用no_open:’0’/‘1’,经过测试[‘0’ == ‘1’ == True] options(o2m关系字段属性) no_edit_no_open:关系字段不允许在当前界打开对应记录的form界面。 批量添加 1.batch_add(新开发js挂件非原生) 直接在o2m的XML字段属性上挂载batch_add=&quot;true&quot;即可。 2.ids_select 这个比较复杂: 1.首先在py文件的头行结构中，定义一个头字段ids_select,字段属性定义如下: ids_select = fields.Char(string=&apos;ids&apos;, help=&apos;This id is to get ids of multiple select of one2many&apos;) 2.然后再XML的头部放入ids_select字段，可影藏，字段定义如下: &lt;field name=&quot;ids_select&quot; class=&quot;oe_o2mx&quot; invisible=&quot;1&quot; on_change=&quot;updateLines(ids_select,o2m_filed,context)&quot;/&gt; 3.绑定对应的o2m字段，将挂件 widget=&quot;o2mx&quot; 加到XML字段属性定义中。对应需o2m_filed的tree上要批量添加的主体字段(m2o_field)挂载 multiple_selection=&quot;true&quot; 属性。 4.对ids_select定义on_change的方法updateLines进行逻辑处理: - 通用结构: if not ids_select: return 0 selected_ids = ids_select.split(&apos;,&apos;) if len(o2m_filed) == 1: change_line = False o2m_filed = self.o2m_filed.browse(o2m_filed[0][2]) else: change_line = True o2m_filed = map(lambda x: x[2], filter(lambda x: x[2], o2m_filed)) res = [] old_value = [] add_ids = [] line_number = 0 for line in o2m_filed: line_number += 1 m2o_field = change_line and line[&apos;m2o_field&apos;] or line.m2o_field.id old_value.append({ &apos;line_number&apos;:line_number, &apos;m2o_field&apos;: m2o_field, &apos;field1&apos;: field1, &apos;field2&apos;: field2, &apos;field3&apos;: field3, ... }) add_ids.append(m2o_field) for id in selected_ids: line = self.env[&apos;selected_ids_model&apos;].browse(int(id)) if int(id) not in add_ids: line_number += 1 res.append({ &apos;line_number&apos;: line_number, &apos;m2o_field&apos;: line.m2o_field.id or False, &apos;field1&apos;: line.field1, &apos;field2&apos;: line.field2, &apos;field3&apos;: line.field3, ... }) if res: return {&apos;value&apos;: {&apos;invoice_detail_ids&apos;: old_value + res}} - 普通 自动递增 递增间隔 最开始的值 Domain XML定义的domain会覆盖字段定义的domain ir.actions.act_window[参数] src_model： 来源模型这个动作应该放在哪个可见的对象可选模型名称(绑定到哪个模型上显示) res_model： 目标模型在视图窗口中打开的对象的模型名称(打开的wizard模型) context: search_default_字段名称: display_filter:在wizard的action上定义如: context=”{‘display_filter’:’invoice_form_view’}”在对应的绑定模型中的context中写入如：context=”{‘invoice_form_view’:1’}”对应绑定的action在限制了view_id,那么这个wizard就唯一绑定在了这个对应的视图上,同模型的其他视图上不显示(一模型多菜单多视图模式)。 execute_method:在wizard的action上定义如: context=”{‘execute_method’:’invoice_execute_method’}”触发action时会直接执行invoice_execute_method方法，但是执行了这个方法就不会直接跳转视图了，你需要在执行的方法中return跳转视图的action。 ‘clear_breadcrumbs’ ‘clear_breadcrumbs’:True可以在视图上隐藏列标题。 res_model: 目标模型 src_model: 原始模型 views: 定义视图类别引用ref view_id: 定义默认打开视图引用ref ir.actions.act_window.view 此模型实际是view_ids的绑定模型,可以通过初始化act_window的view_ids挂在属性值,来控制多个菜单公用一个model,但是打开的是对应的tree、form、search等模型。 1.定义一个action12345678910&lt;record model="ir.actions.act_window" id="hrp_payment_preparation_action"&gt; &lt;field name="name"&gt;Payment Preparation&lt;/field&gt; &lt;field name="res_model"&gt;hrp.payment.request&lt;/field&gt; &lt;field name="view_type"&gt;form&lt;/field&gt; &lt;field name="view_mode"&gt;tree,form&lt;/field&gt; &lt;field name="search_view_id" ref="hrp_payment_preparation_search"/&gt; &lt;field name="domain"&gt;[('state','in',['approved','paying','paid'])]&lt;/field&gt; &lt;field name="context"&gt;&#123;'readonly_by_pass':['company_id','total_amount','invoice_detail_ids','supplier_id','supplier_category_id', 'invoice_date','date_due','payment_method_id','original_amount','open_amount']&#125;&lt;/field&gt;&lt;/record&gt; 2.在action上绑定对应类型的视图外部引用对象1234567&lt;!--供应商预付款申请界面tree视图指定--&gt;&lt;record id="hrp_payment_preparation_tree_view" model="ir.actions.act_window.view"&gt; &lt;field eval="1" name="sequence"/&gt; &lt;field name="view_mode"&gt;tree&lt;/field&gt; &lt;field name="view_id" ref="hrp_payment_preparation_tree"/&gt; &lt;field name="act_window_id" ref="hrp_payment_preparation_action"/&gt;&lt;/record&gt; 1234567&lt;!--供应商预付款申请界面form视图指定--&gt;&lt;record id="hrp_payment_preparation_form_view" model="ir.actions.act_window.view"&gt; &lt;field eval="2" name="sequence"/&gt; &lt;field name="view_mode"&gt;form&lt;/field&gt; &lt;field name="view_id" ref="hrp_payment_preparation_form"/&gt; &lt;field name="act_window_id" ref="hrp_payment_preparation_action"/&gt;&lt;/record&gt; 3.这时候就算一个model上有多个tree视图、多个form视图,甚至是多个search视图等,只要绑定好就会直接打开对应的视图界面,不会打开错咯. 4.如果出现记录单据被通过M2O字段链接的形式跳转过去，那么很可能出现错误，因为点击事件调用了get_formview_action方法，默认获取对应类型视图的view界面，为了在这种情况下不出现错误，我们必须重写get_formview_action方法，提供正确的return导向，也许这里是用的odoo7的写法，在新写法中，我们通过封装@api.v7装饰器，来重载方法，达到我们的目的。]]></content>
      <tags>
        <tag>Odoo-XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-onchange的动态domain]]></title>
    <url>%2Fbbs.github.io%2FOdoo-onchange%E7%9A%84%E5%8A%A8%E6%80%81domain%2F</url>
    <content type="text"><![CDATA[onchange的动态domainOnchange函数可以返回一个字典1234567891011121314on_change in OpenERP has 3 possible values returned finally in a dictionary or a &#123;&#125; .1: The value dictionary i.e &#123;field1:value1,field2:value2&#125;2: The domain dictionary i.e &#123;field1:domain1&#125;3: The warningSyntax:res = &#123;&apos;value&apos;:&#123;&#125;,&apos;domain&apos;:&#123;&#125;,&apos;warning&apos;:&apos;Warning Message&apos;&#125;According to your case add this to the return dictionary.&#123;&apos;domain&apos;:&#123;&apos;partner_id&apos;:[(&apos;customer&apos;,&apos;=&apos;,True)]&#125;&#125; 通过[1]我们可以改变界面上的数值,通过[2]我们可以改变界面取值的域(动态domain),通过[3]可以定义一个警告信息]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-后台任务]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[后台任务目前后台任务分为三种: 自动化任务12345678910111213# - 获取cron_job对象hrp_cron_job_obj = self.env['hrp.cron.job']# - 定义延时执行的时间cron_job_date = fields.Datetime.to_string(datetime.now() + timedelta(seconds=30))# - 直接执行不走cron_job的方法(前期测试使用)# self.create_asset_acceptance_account_move(args)# - 延时凭证生成的方法 必须有需要生成的数据项 这里args如果没有数据 也同样会被封装成 元组|所以需要做一个判断if len(args) &gt; 0 and len(args[0]) &gt; 0: hrp_cron_job_obj.run_by_cron(_("Create Asset Receiving Account Move"),# 自动化任务名称 'hrp.asset.receiving.application',# 自动化任务需要调用的方法所在model 'create_asset_acceptance_account_move',# 方法名 [args],# 参数 date_created=cron_job_date)# 延时时间 分析一下方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def run_by_cron(self, name, model, function, args, priority=10, user_id=False, date_created=False): &quot;&quot;&quot; name - 自动化任务名称 model - 执行方法模型 function - 执行的方法名称 args - 参数 priority - 优先级 user_id - 执行用户 date_created - 开始执行时间 &quot;&quot;&quot; # - 如果没有配置时间 默认立即创建启动执行 if not date_created: date_created = fields.Datetime.now() # - 如果没有执行用户 默认当前登录用户 if not user_id: user_id = self.env.user.id # - 解析参数 这里的参数最好的格式是一个列表传入 args = [repr(arg) for arg in args] # - 创建一个自动化任务 self.create(&#123; &apos;name&apos;: name, &apos;model&apos;: model, &apos;function&apos;: function, &apos;args&apos;: &apos;(%s,)&apos; % (&apos;, &apos;.join(args)), &apos;date_created&apos;: date_created, &apos;user_id&apos;: user_id, &apos;priority&apos;: priority, &#125;) # 在自动化任务的create方法中，直接创建了ir.cron记录: @api.model def create(self, vals): # 创建ir_cron ir_cron_obj = self.env[&apos;ir.cron&apos;] res = super(HrpCronJob, self).create(vals) ir_cron = &#123; &apos;name&apos;: vals[&apos;name&apos;], &apos;active&apos;: True, &apos;user_id&apos;: vals[&apos;user_id&apos;], &apos;priority&apos;: vals[&apos;priority&apos;], &apos;interval_type&apos;: &apos;minutes&apos;, &apos;nextcall&apos;: vals[&apos;date_created&apos;], &apos;numbercall&apos;: 1, &apos;doall&apos;: True, &apos;model&apos;: vals[&apos;model&apos;], &apos;function&apos;: vals[&apos;function&apos;], &apos;args&apos;: vals[&apos;args&apos;], &apos;hrp_cron_job_id&apos;: res.id, &#125; ir_cron_obj.create(ir_cron) return res 队列任务 并发管理器]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[name_get]]></title>
    <url>%2Fbbs.github.io%2Fname-get%2F</url>
    <content type="text"><![CDATA[数据筛选通常我们使用的数据筛选，可能是通过某一个字段A关联的字段范围，来控制B字段的取值，常见的方式就是以添加compute字段的m2m辅助字段来限制B字段的取值范围。这样可能会因为辅助字段上存在_id或者_ids的字段，而使得前台界面加载几十次对应的name_get而转圈。替换方式，去掉辅助字段，在需要被限制字段的XML视图定义中加入相应的context，然后在相应的name_search方法中，获取context，通过中间传入的参数进行数据获取判断后拼接domain，使得界面的值域被修正。例如:1234&lt;field name="partner_id" options="&#123;'no_create_edit':'1','no_create':'1','no_open':'1'&#125;" attrs="&#123;'required':[('partner_force_analytic','=',True)]&#125;" context="&#123;'display_name_and_code':True，'account_id':account_id&#125;"/&gt; 123456789101112131415161718192021222324252627282930313233@api.modeldef name_search(self, name='', args=[], operator='ilike', limit=100): # 如果业务伙伴是通过科目上的业务伙伴核算限制范围的话 我们可以直接用name_search传入context值限制范围 if self._context.has_key('account_id'): account_id = self._context.get('account_id') if account_id: domain = self._get_account_id_limit_domain(account_id) args += domain else: args = [('id', '=', -1)]@api.modeldef _get_account_id_limit_domain(self,account_id=None): # 通过科目上的业务伙伴限制domain值集 account = self.env['account.account'].browse(account_id) supplier = False customer = False employee = False domain = ['|', ('parent_id', '=', False), ('is_company', '=', True)] if account and account.partner_force_analytic: for record in account.partner_force_analytic: if record.code == 'supplier': supplier = True if record.code == 'customer': customer = True if record.code == 'employee': employee = True # 科目上业务伙伴值集domain拼接 domain += supplier and [('supplier', '=', True)] or [('supplier', '=', False)] domain += customer and [('customer', '=', True)] or [('customer', '=', False)] domain += supplier and [('employee', '=', True)] or [('employee', '=', False)] print domain return domain 参考文章]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ir_sequence序列]]></title>
    <url>%2Fbbs.github.io%2Fir-sequence%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[ir_sequence修改序列分析一下，系统中的序列ir.sequence最终还是使用的postgresql的sequence,我们可以通过查找pg_class,通过ir_sequence_(odoo的ir_sequence对应记录的id),12345678910举个例子,总账凭证序列号维护在公司的配置页签上: 1. 我们取到这个序列的ID: sequence_id = self.env[&apos;res.company&apos;].sequence.id 2. 拼接这个序列在pg_class中的序列记录名称: seq_name = &apos;ir_sequence_%03d&apos; % (sequence_id,) 3. 我们尝试着去修改对应的序列开始序号: next_number = 10 &quot;ALTER SEQUENCE %s RESTART WITH %d;&quot; % (seq_name,next_number)]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-安装]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装Odoo10 - Windows - Install1.获取github源码，(github地址) 2.通过clone获取v10源代码git clone https://www.github.com/odoo/odoo –depth 1 –branch 10.0 –single-branch odoo10 安装底层应用依赖资源： 1234567891011121314151617181920212223242526272829303132331.安装python环境这里我们使用annacoda3(https://www.anaconda.com/download/#windows)，由于odoo10以上版本需要使用python3.x，所以我们使用conda指令创建python3.6虚拟环境 &apos;conda create -n py3od11 python=3.6&apos;2. 配置环境变量path(和python的一样 只不过需要配置的时创建的虚拟环境的路径 例如:D:\Anaconda3\envs\py3od11 和 D:\Anaconda3\envs\py3od11\Script)3. python改名 例如虚拟环境路径中：D:\Anaconda3\envs\py3od11 python.exe -&gt; python36.extpythonw.exe -&gt; pythonw36.ext 4. 安装基础必要插件 python36 -m pip install [package_name] Package_name包有如下: pypiwin32 Pillow-3.4.2-cp36-cp36m-win_amd64.whl gevent-1.2.2-cp36-cp36m-win_amd64.whl lxml-3.8.0-cp36-cp36m-win_amd64.whl psutil-5.3.1-cp36-cp36m-win_amd64.whl psycopg2-2.7.3-cp36-cp36m-win_amd64.whl pyldap-2.4.37-cp36-cp36m-win_amd64.whl reportlab-3.4.0-cp36-cp36m-win_amd64.whl 5. 安装odoo必要插件 切换到odoo目录下，你会发现有一个requirements.txt的文件，我们安装它内部的插件: python36 -m pip install -r requirements.txt python36 -m pip install -U werkzeug 安装必要的pdf打印插件 下载wkhtmltopdf 下载一个postgresql的navicat数据库管理软件. 下载并安装postgres10.对应pg的端口请配置好 例如(端口：5432 密码：123456)Postgres下载路径 7.在navicat中连接postgresql数据库. 8.在数据库中创建一个拥有createdb权限的用户 例如：user:odoo pwd:odoo 启动服务通过CMD切换到odoo的文件目录下，执行命令 python36 odoo-bin -s这样会在odoo的文件目录下生成一个odoo.conf的配置文件，我们只需要对文件进行配置修改. 安装完成运行时发现缺少一些关系包 虽然这些在requirements.txt包含，但是估计批量没安装成功 我们手动安装一下python36 -m pip install 包名 如：PyPDF2 passlib python-dateutil pywin32 PyYAML Pillow jinja2 html2text num2words等，运行时报错缺什么就装什么 为了启动能够连接到对应的数据库，我们需要修改对应的odoo.conf文件例如我修改后的配置文件:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[options]addons_path = D:\odoo11plus\odoo\odoo\addons,D:\odoo11plus\odoo\addonsadmin_passwd = handhandcsv_internal_sep = ,data_dir = D:\odoo11plus\data_dirdb_host = localhostdb_maxconn = 64db_name = Falsedb_password = odoodb_port = 5432db_sslmode = preferdb_template = template1db_user = odoodemo = &#123;&#125;email_from = Falsegeoip_database = /usr/share/GeoIP/GeoLite2-City.mmdbhttp_enable = Truehttp_interface = http_port = 8069import_partial = limit_memory_hard = Nonelimit_memory_soft = Nonelimit_request = Nonelimit_time_cpu = Nonelimit_time_real = Nonelimit_time_real_cron = Nonelist_db = Truelog_db = Falselog_db_level = warninglog_handler = :INFOlog_level = infologfile = Falselogrotate = Falselongpolling_port = 8072max_cron_threads = 2osv_memory_age_limit = 1.0osv_memory_count_limit = Falsepg_path = C:\Program Files\PostgreSQL\10\binpidfile = Falseproxy_mode = Falsereportgz = Falseserver_wide_modules = websmtp_password = Falsesmtp_port = 25smtp_server = localhostsmtp_ssl = Falsesmtp_user = Falsesyslog = Falsetest_commit = Falsetest_enable = Falsetest_file = Falsetest_report_directory = Falsetranslate_modules = [&apos;all&apos;]unaccent = Falsewithout_demo = Falseworkers = None 必须配置的有: admin_passwd、db_host、db_port、db_user、db_password、pg_path 其他的按情况配置. 12.为了工程化操作，我们可以在pycharm中直接创建一个启动项: 之后我们只需要在pycharm选择对应的启动服务，点击运行 就可以使用odoo服务了。 前台创建数据库并登入: 后记：写的粗糙，后期继续细化，另外如果把python的应用放到docker镜像中，在本地使用postgresql10的数据库服务，那样的开发应该是最适合的，以后补充。 Odoo12安装补充首先Odoo12采用的不再是less的css加载，而是node-sassc.pip3 install libsass Odoo安装叮嘱 模块上demo就算想使用demo文件，也配置了 结果安装后就是不生效:因为从前台创建数据库的时候]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitbook使用]]></title>
    <url>%2Fbbs.github.io%2FGitbook%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用说明文档安装流程 首先在你的本地需要如下软件： Git ① 、Gitbook Editor ② 下载安装完成后，选择一个对应的目录，获取对应书籍: 2.1 Windows获取方式： &emsp;&emsp;1. 选择一个适当的目录，鼠标点击右键，选择[] &emsp;&emsp;2. 输入：git clone https://rdc.hand-china.com/gitlab/13035/gitbook_test.git 2.2 Mac获取方式： &emsp;&emsp;打开终端，选择一个合适的目录，比如 /User/用户名/XXX,在终端执行： &emsp;&emsp;&emsp;&emsp; 1. cd /User/用户名/XX &emsp;&emsp;&emsp;&emsp; 2. git clone https://rdc.hand-china.com/gitlab/13035/gitbook_test.git &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 安装过程中可能需要输入账户/密码(工号/handhand) 使用流程 &emsp;&emsp;正在努力编写中… 资源&emsp;&emsp;①&emsp;Git下载地址 &emsp;&emsp;②&emsp;Gitbook Editor下载地址 &emsp;&emsp;&emsp;&emsp;上述连接如果下载速度慢请移步: &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Git-Windows64位 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Git-MacOS暂时未上传 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Gitbook Editor - Windows64位 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Gitbook Editor - MacOS位]]></content>
      <tags>
        <tag>Gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu基础]]></title>
    <url>%2Fbbs.github.io%2FUbuntu%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[新安装ubuntu打开22端口12345678910ssh操作时出现： ...Connection failed. Type `help&apos; to learn how to use Xshell prompt.首先关闭ubuntu防火墙： sudo ufw disable然后安装OpenSSH: sudo apt-get install openssh-server openssh-client(如果没联网 首先处理网络连接)网络测试： netstat -tnl现在可以直接使用ssh连接了 Ubuntu vi/vim 上下左右删除按键转译成ABCD1234解决办法: echo &quot;set nocp&quot; &gt;&gt; ~/.vimrc source ~/.vimrc Ubuntu 换源123456789101112131415161718192021222324252627282930313233换成国内最快的阿里云源 第一步：备份原来的源文件 cd /etc/apt/ 然后会显示下面的源文件sources.list 输入命令 sudo cp sources.list sources.list.bak 就是将sources.list备份到sources.list.bak第二步：替换源 阿里云源的文件 vi sources.list 删除原内容，输入以下内容（输入之前换root权限，输入命令sudo su） deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # 源码 deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # Canonical 合作伙伴和附加 deb http://archive.canonical.com/ubuntu/ xenial partner deb http://extras.ubuntu.com/ubuntu/ xenial main第三步：更新源和软件 sudo apt-get update 更新源 sudo apt-get upgrade 更新软件 Ubuntu TomcatTomcat卸载并安装]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo数据校验约束]]></title>
    <url>%2Fbbs.github.io%2FOdoo%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[Odoo的数据约束抛错可分为三种情况 手动判断约束(create/write) ORM层约束(api constrains) 数据库层约束(_sql_constrains) 从系统的执行优先级来看，顺序依次是 手动判断约束 -&gt; 数据库层约束 -&gt; ORM层约束 三种约束尽量不要同时使用，比如如果使用了手动判断约束，如果再添加了ORM层约束，通过ORM的search或者search_count方法搜出来的数据是包含当前正在创建并没有写入数据库的数据项。 1.手动约束：通过在model的create或者write方法中写条件判断，然后手动raise信息，这样可以控制抛错逻辑和抛错提示信息，比较常见。但需要注意的是，也许create/write的vals中需要校验的字段不一定是必输的，也就是说vals中可能缺失需要校验的值，这个一定好考虑到。 2.ORM层约束：通过写@api.constrains方法，来对数据库列进行进行判断，可以控制判断逻辑和抛错。但需要注意，如果新创建单据的话，这个地方通过ORM会搜索到新创建的记录对象，可能需求是校验唯一性，这样的话ORM方法来判断就不是适用了。而且只有单据执行create和write方法后，才能走此校验api. 3.数据库层约束：直接给数据库表添加约束条件，无论是前台还是后台创建数据都会被校验，缺点是不能不能自己写复杂的判断逻辑，而且抛错会抛系统的key重复错误之类的。 1-2抛错：3抛错：]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo开发模板]]></title>
    <url>%2Fbbs.github.io%2FOdoo%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[基础model开发模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# -*- coding: utf-8 -*-#################################################################### 文件功能描述###################################################################from openerp import models, fields, api, _from openerp.exceptions import ValidationErrorimport openerp.addons.decimal_precision as dpfrom openerp.tools import float_compare&lt;!--more--&gt;class XXX(models.Model): """ 模型基本描述： XXX 详细描述： XXX 属性说明： XXX """ _name = 'XXX' _description = 'Model Description' # _rec_name = 'id' # Declaring Functions Begin # Declaring Functions End # 名称 name = fields.Char(string='Name', help='Name', default='/') # My Functions Begin @api.model def check_all(self, rec, vals, type, *args, **kwargs): """ 模型的通用校验方法 (ValidationError) :param rec: 记录对象 :param vals: create/write的数据字典，也可以是别的方法使用的字典 :param type: 区分检查逻辑块的标志 :param args: 动态浮动参数 :param kwargs: 动态指定参数 :return: 支持返回值,如果需要一定的返回值请自行写return """ if type == 'create': pass elif type == 'write': pass elif type == 'other1': pass # return XXX elif type == 'other2': pass else: pass # My Functions End # ORM Functions Begin @api.model def create(self, vals): # 当前的各种校验 self.check_all(rec=self, vals=vals, type='create') return super(XXX, self).create(vals) @api.multi def write(self, vals): for rec in self: # 当前的各种校验 self.check_all(rec=rec, vals=vals, type='write') return super(XXX, self).write(vals) @api.multi def unlink(self): for rec in self: pass return super(XXX, self).unlink() # ORM Functions End # Button Functions Begin # Button Functions End 基础XML视图开发模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;openerp&gt; &lt;data&gt; &lt;!--tree视图--&gt; &lt;record id="XXX_tree" model="ir.ui.view"&gt; &lt;field name="name"&gt;XXX_tree&lt;/field&gt; &lt;field name="model"&gt;XXX&lt;/field&gt; &lt;field name="arch" type="xml"&gt; &lt;tree&gt; &lt;field name="name"/&gt; &lt;/tree&gt; &lt;/field&gt; &lt;/record&gt; &lt;!--Form视图--&gt; &lt;record id="XXX_form" model="ir.ui.view"&gt; &lt;field name="name"&gt;XXX_form&lt;/field&gt; &lt;field name="model"&gt;XXX&lt;/field&gt; &lt;field name="arch" type="xml"&gt; &lt;form&gt; &lt;header&gt; &lt;!--&lt;button name="button_xxx" type="object" string="Button Name XXX"--&gt; &lt;!--class="oe_highlight" attrs="&#123;'invisible':[('state','not in',('created'))]&#125;"/&gt;--&gt; &lt;!--&lt;field name="state" widget="statusbar" statusbar_visible="created,done"/&gt;--&gt; &lt;/header&gt; &lt;sheet&gt; &lt;!--&lt;div class="oe_right"--&gt; &lt;!--style="width:30%;padding-top:15px;display:inline;height:58px;position:relative"--&gt; &lt;!--name="buttons"&gt;--&gt; &lt;!--界面跳转链接按钮--&gt; &lt;!--&lt;button type="object" style="position:absolute;right:80px" name="action_button_name_XXX"--&gt; &lt;!--class="oe_stat_button" icon="fa-credit-card"&gt;--&gt; &lt;!--链接单据数量 自己去py里写一个字段用compute形式动态计算--&gt; &lt;!--&lt;field name="num" string='Number' widget="statinfo"/&gt;--&gt; &lt;!--&lt;/button&gt;--&gt; &lt;!--&lt;/div&gt;--&gt; &lt;group&gt; &lt;group&gt; &lt;field name="name" invisible="1"/&gt; &lt;!--&lt;field name="Many2one_field"--&gt; &lt;!--attrs="&#123;'required':True,'readonly':[('state','!=','created')]&#125;"--&gt; &lt;!--options="&#123;'no_create_edit':'1','no_create':'1','no_open':'1'&#125;"/&gt;--&gt; &lt;/group&gt; &lt;group&gt; &lt;!-- ... --&gt; &lt;/group&gt; &lt;/group&gt; &lt;notebook&gt; &lt;page string="Page Name"&gt; &lt;field name="XXX_ids" options="&#123;'no_edit_no_open':True&#125;" attrs="&#123;'invisible':[('state','not in',('created'))]&#125;"&gt; &lt;tree editable="bottom/top" default_order="code" &gt; &lt;field name="code" /&gt; &lt;field name="name" /&gt; &lt;field name="xxx_id" options="&#123;'no_create_edit':'1','no_create':'1','no_open':'1'&#125;" attrs="&#123;'invisible':[('state','not in',('created'))]&#125;"/&gt; &lt;/tree&gt; &lt;/field&gt; &lt;/page&gt; &lt;!--&lt;page&gt;...&lt;/page&gt;--&gt; &lt;/notebook&gt; &lt;/sheet&gt; &lt;/form&gt; &lt;/field&gt; &lt;/record&gt; &lt;!--搜索视图--&gt; &lt;record id="XXX_search" model="ir.ui.view"&gt; &lt;field name="name"&gt;XXX_search&lt;/field&gt; &lt;field name="model"&gt;XXX&lt;/field&gt; &lt;field name="priority"&gt;10&lt;/field&gt; &lt;field name="arch" type="xml"&gt; &lt;search string="Search Name"&gt; &lt;field name="name"/&gt; &lt;filter name="XXX" icon="terp-camera_test" string="XXX" domain="[('XXX','=','XXX')]" help="XXX"/&gt;&lt;separator/&gt; &lt;group expand="0" string="Group By"&gt; &lt;filter string="XXX" icon="terp-folder-orange" domain="[]" context="&#123;'group_by':'fields_name_XXX'&#125;"/&gt; &lt;/group&gt; &lt;/search&gt; &lt;/field&gt; &lt;/record&gt; &lt;!--动作--&gt; &lt;record model="ir.actions.act_window" id="XXX_action"&gt; &lt;field name="name"&gt;XXX Action&lt;/field&gt; &lt;field name="res_model"&gt;XXX&lt;/field&gt; &lt;field name="view_type"&gt;form&lt;/field&gt; &lt;field name="view_mode"&gt;tree,form&lt;/field&gt; &lt;/record&gt; &lt;!--顶级菜单--&gt; &lt;menuitem id="top_XXX_menu" name="XXX" sequence="10" /&gt; &lt;!--二级菜单--&gt; &lt;menuitem id="XXX2_menu" name="XXX" parent="top_XXX_menu" sequence="10" /&gt; &lt;!--三级菜单--&gt; &lt;menuitem id="XXX3_menu" name="XXX3 Menu" parent="XXX2_menu" sequence="10" action="XXX_action"/&gt; &lt;/data&gt;&lt;/openerp&gt;]]></content>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fbbs.github.io%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建Github Page + Hexo博客系统]]></title>
    <url>%2Fbbs.github.io%2FHexo%2BGituhb%E9%A1%B5%E9%9D%A2%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[虽然网上有很多教程了，但是我还是想把自己的参考历程贴出来，给自己做一个参考 参考文档：使用Hexo+Github一步步搭建属于自己的博客（基础） 这里我只写简要的过程(Macbook Pro) 访问github创建一个新的博客仓库，仓库名称规格 XXX.github.io 提前安装好npm,使用npm安装hexo: npm install hexo -g 安装完成后，使用hexo -v检查是否安装成功 安装需要的组建 npm install 加载hexo: hexo g 启动访问服务: hexo s 通过http://localhost:4000访问本地Hexo博客(注意如果启动服务后，界面转圈，说明4000端口被占用，我们换4001端口尝试访问http://localhost:4001) 访问成功后，hexo绑定github page: git配置： git config –global user.name ‘Name’ git config –global user.email &#39;Mail@163.com‘ github 上传公钥(参考) 进入hexo的_config.yml文件绑定github page:滑动到文档末尾，添加： deploy: type: git repository: git@github.com:XXX/XXX.github.io.git(工程路径) branch: master 扩展一步上传博客内容到github仓库的组建：npm install hexo-deployer-git –save 创建博客：hexo new post “博客名称” 博客内容都在source/_post/目录中：同步更新到github page：hexo d -g 现在访问：https://github账户.github.io/博客工程名称/ 可能发现界面上的样式都失效了，因为我们没有定义_config的url： 1234url: https://XXX.github.io/XXX.github.io/root: /XXX.github.io/permalink: :year/:month/:day/:title/permalink_defaults: 再次访问后成功。 附： &emsp;&emsp;① _config参数说明 &emsp;&emsp;]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
