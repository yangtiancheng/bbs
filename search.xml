<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重写源码action]]></title>
    <url>%2Fbbs.github.io%2Frewrite-action%2F</url>
    <content type="text"><![CDATA[重写源码action或者更新record数据柄属性场景简述也许一个源码的菜单，限制了展示的值范围为id &gt; 100的数据 domain = [(‘id’,’&gt;’,100)]在我们自己的个性化代码中，可能需要将显示范围改成 id &gt; 200。 操作及理念 Odoo通过XML产生的数据，不仅仅会创建对应的模型记录数据，同时会将数据集绑定创建一条ir.model.data的数据。 我们只需要在自己的个性化模块中重写对应的action修改domain属性即可，但是由于所处模块(module)的不同，我们重写的action必须指定要覆盖的模块。 所以在外部ID-extend_id前面加上module的前缀，即module.action_extend_id格式即可。 代码示例 查看信息12345-- 查询当前action与data的关键参数select imd.id,imd.module 所处模块,iaw.id 动作ID, iaw.domain 动作域from ir_model_data imd,ir_act_window iawwhere imd.res_id = iaw.idand imd.name = &apos;rounding_list_action&apos;; 重写方法 1234567891011121314151617181920212223&lt;!-- 所处模块(module)为源码account 原始action--&gt;&lt;record id="rounding_list_action" model="ir.actions.act_window"&gt; &lt;field name="name"&gt;Cash Roundings&lt;/field&gt; &lt;field name="res_model"&gt;account.cash.rounding&lt;/field&gt; &lt;field name="view_type"&gt;form&lt;/field&gt; &lt;field name="view_mode"&gt;tree,form&lt;/field&gt; &lt;field name="domain"&gt;[('id','&gt;',100)]&lt;/field&gt; &lt;field name="help" type="html"&gt; &lt;p class="o_view_nocontent_smiling_face"&gt;Create the first cash rounding&lt;/p&gt; &lt;/field&gt;&lt;/record&gt;&lt;!--所处模块(module)为个性化my_module --&gt;&lt;record id="account.rounding_list_action" model="ir.actions.act_window"&gt; &lt;field name="name"&gt;Cash Roundings&lt;/field&gt; &lt;field name="res_model"&gt;account.cash.rounding&lt;/field&gt; &lt;field name="view_type"&gt;form&lt;/field&gt; &lt;field name="view_mode"&gt;tree,form&lt;/field&gt; &lt;field name="domain"&gt;[('id','&gt;',200)]&lt;/field&gt; &lt;field name="help" type="html"&gt; &lt;p class="o_view_nocontent_smiling_face"&gt;Create the first cash rounding&lt;/p&gt; &lt;/field&gt;&lt;/record&gt; 升级后查询]]></content>
      <categories>
        <category>Odoo,XML</category>
      </categories>
      <tags>
        <tag>Odoo,XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django新手入门01 - Model]]></title>
    <url>%2Fbbs.github.io%2Fdjango%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A801%2F</url>
    <content type="text"><![CDATA[Queries「查询」Create objects 「创建新对象」使用model实例类 通过**kwargs赋值创建实例 123from blog.models import Blogb = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')b.save() Saving changes to objects which already in DB(Normal UPDATE)12b.name = 'XXX'b.save() Saving ForeignKey and M2m Fields(Special Fields UPDATE)123456789101112131415161718# FKfrom blog.models import Blog, Entryentry = Entry.objects.get(pk=1)cheese_blog = Blog.objects.get(name="Cheddar Talk")entry.blog = cheese_blogentry.save()# M2m TODO:Use add()from blog.models import Authorjoe = Author.objects.create(name="Joe")entry.authors.add(joe)# M2m Multi add()john = Author.objects.create(name="John")paul = Author.objects.create(name="Paul")george = Author.objects.create(name="George")ringo = Author.objects.create(name="Ringo")entry.authors.add(john, paul, george, ringo) Notice: M2m中add的objects如果类型错误，Django将会报错。 Search objects class_name.objects 中 objects就是当前类的Manager，切记实例无法使用objects. QuerySet是Select，而filters是Where。 Class.objects.all() 查找当前表的所有记录。 filter(**kwargs) 筛选 Entry.objects.filter(pub_date__year=2006) 等价 Entry.objects.all().filter(pub_date__year=2006) exclude(**kwargs) 排除 Entry.objects.exclude(pub_date__year=2006) 等价 Entry.objects.all().exclude(pub_date__year=2006) 4和5可以连在一起用 Entry.objects.filter(pub_date__year=2006).exclude(pub_date__year=2007) 4和5尽量分开处理，用变量存储。 定义filter和exclude的时候，代码并不会执行，除非调用当前筛选逻辑 比如print(X) get()1one_entry = Entry.objects.get(pk=1) get()有且必须只能找到1条记录。 get()的用法和filter()相同，不同的是如果get()获取不到对象，则会返回 DoesNotExist 异常。 如果获取到多个记录，则会返回 MultipleObjectsReturned 异常。 除过all、get、filter、exclude 更多请查阅QuerySet API Limit QuerySets1234Entry.objects.all()[Offset:Limit:Step]Entry.objects.all()[:5]Entry.objects.all()[:5:10]Entry.objects.all()[:10:2] # - 使用step会重新从数据库执行查询 其他只是querysets切片成new querysets. Field Lookups field__exact=1 等价SQL-WHERE: field=1 field__iexact=1 不区分大小写 field__contains=’Lennon’ 等价SQL-WHERE:SELECT … WHERE headline LIKE ‘%Lennon%’; field__icontains=’Lennon’ 不区分大小写 startswith\endswith\istartswith\iendswith等. 更多参阅[链接](https://docs.djangoproject.com/en/2.2/ref/models/querysets/#field-lookups) 支持跨越关系（外键表）指定 Blog.objects.filter(entry__headline__contains=’Lennon’) 支持反向搜索(小写class名称) CURRENT ENDSWITH : Spanning multi-valued relationships¶链接]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gevent+prefork]]></title>
    <url>%2Fbbs.github.io%2Fgevent-prefork%2F</url>
    <content type="text"><![CDATA[osos.fork()]]></content>
  </entry>
  <entry>
    <title><![CDATA[基础字段用法提示]]></title>
    <url>%2Fbbs.github.io%2F%E5%9F%BA%E7%A1%80%E5%AD%97%E6%AE%B5%E7%94%A8%E6%B3%95%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[字段default=function123456789@api.modeldef _get_company(self): if 1 == 1: return self.env.user.company_id.id else: return False# 公司company_id = fields.Many2one(comodel_name='res.company', string='Company', help="Company", index=True, default=_get_company) 注意_get_company的方法一般用api.model装饰器修饰，default的属性接收值是对应数据的ID，不是对象，切记!!! 字段domain前后用法]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态显示Selection的选项域]]></title>
    <url>%2Fbbs.github.io%2F%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BASelection%E7%9A%84%E9%80%89%E9%A1%B9%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[简介一个模型，两个form视图，对应的selection字段值域不同 直接代码上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950odoo.define('select_hide.hide_selection_units', function (require) &#123; "use strict"; var registry = require('web.field_registry'); var relational_fields = require('web.relational_fields'); var FieldSelection = relational_fields.FieldSelection; var rpc = require('web.rpc'); var select_hide_by_condition = FieldSelection.extend(&#123; _renderEdit: function () &#123; self = this; // model function_model function_name field_name var function_name = self.attrs.function; var value = this.value; if (self.$el[0].options.length == 0) &#123; if (this.field.type === 'selection') &#123; rpc.query(&#123; "model": this.model, "method": function_name, "args": [&#123;'args': this.recordData&#125;], &#125;).then(function (result) &#123; if (!!result) &#123; self.$el.empty(); for (var i = 0; i &lt; result.length; i++) &#123; self.$el.append($('&lt;option/&gt;', &#123; value: JSON.stringify(result[i][0]), text: result[i][1] &#125;)); &#125; &#125; &#125;); &#125; else &#123; for (var i = 0; i &lt; this.field.selection.length; i++) &#123; this.$el.append($('&lt;option/&gt;', &#123; value: JSON.stringify(this.field.selection[i][0]), text: this.field.selection[i][1] &#125;)); &#125; &#125; &#125; if (this.field.type === 'many2one' &amp;&amp; value) &#123; value = value.data.id; &#125; &#125;, &#125;); registry .add('select_hide_by_condition', select_hide_by_condition);&#125;); 1&lt;field name="source_type" widget="select_hide_by_condition" function="select_hide_by_condition"/&gt; 1234567891011121314151617181920@api.modeldef select_hide_by_condition(self, datas): """ 来源类型 选择框数据限制 :param datas: 当前数据行的所有字段信息 :return: 新的选择框值域 """ if datas['args']['XXX']: return [ ('table_item', _('Table Item')), ('code', _('Code')), ('mapping_table', _('Mapping Table')), ] else: return [ ('', ''), ('table_item', _('Table Item')), ('code', _('Code')), ('mapping_table', _('Mapping Table')), ]]]></content>
      <categories>
        <category>Odoo,JS,Selection</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[res.users]]></title>
    <url>%2Fbbs.github.io%2Fres-users%2F</url>
    <content type="text"><![CDATA[function has_group参数group_ext_id - 组 外部ID]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[model文件]]></title>
    <url>%2Fbbs.github.io%2Fmodel%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[function read参数：fields - 记录返回字段列表load - 暂时不知 简介：Read方法其实就是读指定self中字段的数据记录，通常在python代码里用browse方法代替可能会出现异常: 给定的记录当前用户没有可读的权限 首先检查用户对模型的访问权限 check_access_rights 检查用户对字段模型的访问权限 check_field_access_rights function check_access_rights参数：operation - 操作方式 read\write\create\unlinkraise_exception - 异常是否抛出 默认t 简介：查询当前用户对于当前模型是否有相关的权限 function check_field_access_rights参数：operation - 操作方式 read\write\create\unlinkfields - 检查的字段 简介：检查当前用户对给定的字段是否有访问权限，如果没有抛出例外，否则将会返回字段列表 超级管理员直接返回随影的字段 普通人员 对于没提供fields参数字段时，查询当前记录的所有字段_fields,并验证每一个字段是否有效(valid) 将提供的字段分为 存储、继承、计算 三种类型，切记fields中不能出现不属于当前模型的字段名 对于存储和继承的字段，通过数据库查找 _read_from_database 内部方法：function valid参数：fname - 字段名称 简介：通过字段是否有组权限，如果有，检查用户有没有这些组权限 user_has_groups。 function user_has_groups参数：groups - (str)完整的组外部数据记录，通过逗号分隔 例如：base.group_user,base.group_system,每一个组前面可选加感叹号’!’，例如：!base.group_user,!base.group_system 返回 - 如果当前用户是给定组(非!前缀)的成员，并且不是任何组给定前缀组(!前缀)的成员，返回t简单理解就是：给了组，用户是非!前缀组的成员，并且不是任何!前缀组的成员。 简介：如果用户是“groups”中至少一个组的成员，并且“groups”不是中以“!”开头的任何组的成员，则返回true！通常用于解析视图和模型定义中的“groups”属性。 首先将groups根据逗号分开，对每一个组外部ID去除空格、换行符。 将提供的groups分成!前缀组集合not_has_groups(添加时去掉前缀!)，和没有!前缀的组集合has_groups。 检查not_has_groups中的每一个组3.1 如果是’base.group_no_one’组，检查用户是否在’base.group_no_one’组中，环境栈中是否是debug模式，满足上述条件，返回 False ，因为是not_has_groups3.2 如果是其他组，检查用户是否在当前组内，如果在，返回 False 上面条件都ok的情况下，检查has_groups中的每一个组4.1 如果是’base.group_no_one’组，检查用户是否在’base.group_no_one’组中，环境栈中是否是debug模式，满足上述条件，返回 True ，因为是has_groups4.2 如果是其他组，检查用户是否在当前组内，如果在，返回 True 如果没有提供groups参数值，返回 True function _read_from_database参数field_names - 存储字段名称列表inherited_field_names - 继承字段名称列表 简介查询self对应的数据库字段，将结果存储在缓存中、如果有错误也存在缓存中 如果self没有记录就跳出， function _where_calc参数domain - 域active_test - 是否用active字段筛选 默认t返回 - Query查询对象 简介如果模型有active字段，参数active_test控制是否添加domain -&gt; (‘active’, ‘=’, 1) class expressionfunction init参数domain - 域列表model - 模型记录 ### function sudo]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的Many2many]]></title>
    <url>%2Fbbs.github.io%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Many2many%2F</url>
    <content type="text"><![CDATA[你关联我，我关联你，我们同用一个relation1. 举个🌰12_name = "res.groups"users = fields.Many2many('res.users', 'res_groups_users_rel', 'gid', 'uid') 12_name = "res.users"groups_id = fields.Many2many('res.groups', 'res_groups_users_rel', 'uid', 'gid') 2. 分析从上面的例子可以看出，两个字段使用了同一个relation(res_groups_users_rel),之前说好的relation唯一 不能和任何表名重复吗? 对，这也没问题。其实m2m本来就是两张表数据存在的一种互相多关联关系，你关联我，我关联你，只要我们对应的数据位置保持一致就行。数据保持一致，就要求column1必须是本模型model的数据，column2必须是关联表模型comodel_name的数据，切记不能写错咯~]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ir.rule]]></title>
    <url>%2Fbbs.github.io%2Fir-rule%2F</url>
    <content type="text"><![CDATA[什么是ir.rule前面我们讲过了模型访问规则ir.model.access，这里的ir.rule是数据屏蔽规则，简单的说就是谁能看见哪些数据。 字段name - 名称active - 有效性model_id - 模型groups - 组domain_force - 可访问条件域perm_read - 可读perm_write - 可写perm_create - 可创perm_unlink - 可删 提示：perm = permission(许可) 批量写data.xml的权限部分1234567891011121314151617181920212223242526272829303132333435363738def test(): models = [ 'account.account', 'account.move', 'account.move.line', ] """ -- 用这个SQL可以查到对应 有公司字段且为company_id的model select model from ir_model_fields imf where model in ( 'account.account', 'account.move', 'account.move.line', ) and ttype='many2one' and name = 'company_id' and relation = 'res.company'; """ print('&lt;data noupdate="1"&gt;') for model in models: print(""" &lt;record id="&#123;0&#125;" model="ir.rule"&gt; &lt;field name="name"&gt;&#123;1&#125;&lt;/field&gt; &lt;field name="model_id" ref="&#123;2&#125;"/&gt; &lt;field name="global" eval="True"/&gt; &lt;field name="domain_force"&gt; ['|',('company_id', '=', False),'&amp;amp;', ('company_id', 'child_of', [user.company_id.id]), ('company_id', 'in', user.company_ids.ids)] &lt;/field&gt; &lt;/record&gt;""".format(model_name_transfor_table_name('rule_'+model),model_name_transfor_table_name(model+'_rule'),model_name_transfor_table_name('model_'+model))) print('&lt;/data&gt;')# 模型转表def model_name_transfor_table_name(model_name): return model_name.replace('.', '_')test()]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ir.model.access]]></title>
    <url>%2Fbbs.github.io%2Fir-model-access%2F</url>
    <content type="text"><![CDATA[什么是ir.model.access简单的说，ERP的资源管理，其实不外四种情况（增删改查），那么对于登录用户来说，你有权限做这些操作码？如果不做限制，岂不是随便的一个用户就能轻易的动系统的数据，这是很可怕的。 模型权限文件有name,active,model_id(非TransientModel模型),group_id,perm_read,perm_write,perm_create,perm_unlink几个字段。 function check_groups参数：group =&gt; module.group_ext_id 检查当前用户是否在所提供的组里，返回t/f function check_group参数：model - 模型名(如果传入模型对象 将模型名 model.name 取出)mode - 检查方式group_ids - 组 检查改模型model是否可以被提供的组group_ids 或 组为空时访问，返回t/f function group_names_with_access参数：model_name - 模型名access_mode - 检查方式 查询当前模型是否有满足检查方式access_mode的组记录，如果有，将这些组以 module_category/group_name的列表形式返回 function check1. admin用户超级用户拥有所有权限 跳过校验 2. 普通用户 对于TransientModel模型,所有用户可跳过校验 对于普通模型，检查用户权限组是否存在符合此权限的有效记录如果没有，检查用户是否存在组为空的有效权限记录。如果没有查找到记录，查一下系统中是否有可以访问该model的组! 如果有：12_(&quot;Sorry, you are not allowed to [access/modify/create/delete] this document.&quot;),只有以下访问等级(组)的用户可才做这：category_id1/group1，category_id2/group2... 如果没有： 12_(&quot;Sorry, you are not allowed to [access/modify/create/delete] this document.&quot;),如果你认为这是一个错误，请联系你的系统管理员。 类变量_cache_clearing_methods = set() function register_cache_clearing_method参数：model - 模型名method - 方法名 将(model,method)添加到类变量__cache_clearing_methods中 function unregister_cache_clearing_method参数：model - 模型名method - 方法名 将(model,method)从类变量__cache_clearing_methods中移除 function call_cache_clearing_methods 清空当前ir.model.access模型记录的缓存 清空ir.model.access的check方法的缓存 __cache_clearing_methods变量中的模型方法 统一执行一遍(测试看都是在清除缓存) function create/write/unlink都会先执行call_cache_clearing_method清一遍缓存，再执行ORM操作。 问题：最后的清楚缓存部分，为什么要这么做？希望有知道的odooer帮忙指点迷津~]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL的!=和is not NULL]]></title>
    <url>%2Fbbs.github.io%2FSQL%E7%9A%84-%E5%92%8Cis-not-NULL%2F</url>
    <content type="text"><![CDATA[!=12select type,*where type != 'normal' SQL的Where语句如果出现!=判断符，DB会将数据中type有值且不等于normal的记录查出，但如果记录中对应的type字段是NULL的话，数据将不会被查出来。 is not NULL12select type,*where type is not NULL 将查出type非空的记录 这里需要特别注意筛选数据时，最好不要用!=，除非特别确认这个字段一定是必输字段。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo 浅谈Odoo提供的附件机制]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E6%B5%85%E8%B0%88Odoo%E6%8F%90%E4%BE%9B%E7%9A%84%E9%99%84%E4%BB%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Odoo提供的附件机制 存储位置可配置：&emsp;&emsp;通过 设置-参数-系统参数 定义的关键字ir_attachment.location来控制附件的存储方式。 1.如果未维护记录或者维护记录值不为db，默认存储路径为应用服务器上的/var/lib/odoo/filestore/数据库名称/文件夹,例如/var/lib/odoo/filestore/ 868/9c。 2.将文件的路径写入store_fname字段，file_size表示文件大小，db_datas表示文件以二进制的形式存储在数据库中(这里为空)。 3.如果维护记录值为db，则以binary的形式存储在数据库表db_datas中。 个人总结 可配置存储方式:我们的所有附件数据可以选择保存在数据库db_datas中，还是应用服务器/var/lib/odoo/数据库名/sha1[:2]中。如果保存在应用服务器中，系统的数据库会更加轻便，而且附件使用base64编码文件，通过sha1方式给每一个附件文件标定为唯一的记录datas_fname，如果上传相同的文件，数据库store_fname记录只需要放入文件的服务器软地址，不需要再将文件上传，加速了上传的效率。 同一记录单或不同记录单，相同的文件只会上传一次:数据库记录只需要放入相关的访问地址，需要时直接读取，防止多余的空间流失。HRP现有的资质的附件上传方式，采用数据库直接存取二进制文件形式，上传文件就接收，不校验，不智能，数据冗余，使得数据库臃肿不堪。 权限检查-更安全：对系统附件的每一种类型的操作，odoo源码附件机制都会检验权限是否满足，只有附件上传者、超级管理员、管理组用户才可以对相关附件进行高级操作，保证了操作附件的安全性。 不易丢失:选择应用服务器保存附件，极端情况下，当数据库数据丢失或损坏时，存储在服务器端的附件不会受到波及，防止数据丢失。 异步备份：虽然看起来既要备份数据库，又要备份应用服务器的附件部分，操作步骤变多了。但分步备份保证了数据库快速备份，服务器附件传输要求并不像数据库备份时，要求快速、轻便，所以这样的机制更适合 ###如有理解错误的地方，请大家指正.]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo12-M2m字段添加一行弹出框内容个性化指定视图+action自定义指定视图]]></title>
    <url>%2Fbbs.github.io%2FOdoo12-M2m%E5%AD%97%E6%AE%B5%E6%B7%BB%E5%8A%A0%E4%B8%80%E8%A1%8C%E5%BC%B9%E5%87%BA%E6%A1%86%E5%86%85%E5%AE%B9%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8C%87%E5%AE%9A%E8%A7%86%E5%9B%BE-action%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E5%AE%9A%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[m2m字段的context属性接收一个 tree_view_ref 属性，通过它指定特定的打开视图即可。举个例子： 1. 首先自定义一个打开字段模型的tree视图：123456789101112&lt;!--Tree M2M Select View--&gt; &lt;record model="ir.ui.view" id="&#123;tree_id&#125;"&gt; &lt;field name="name"&gt;Tree M2M Select View&lt;/field&gt; &lt;field name="model"&gt;&#123;model_name&#125;&lt;/field&gt; &lt;field name="priority" eval="20"/&gt; &lt;field name="arch" type="xml"&gt; &lt;tree&gt; &lt;field name="name"/&gt; &lt;field name="active_flag"/&gt; &lt;/tree&gt; &lt;/field&gt; &lt;/record&gt; 注意：&emsp;&emsp;最好指定一个priority属性值&gt;16，否则可能会将你原来model的tree视图也跳转到新写的tree上了(odoo8中会出现这个情况 默认值16 加载默认取最新的视图)；或者，你可以在action上指定一个view_ids,保证原生的视图一定连接到对应的类型视图：1234&lt;field name="view_ids" eval="[(5, 0, 0), (0, 0, &#123;'view_mode': 'tree', 'view_id': ref('&#123;module_name&#125;.&#123;tree_view_id&#125;')&#125;), (0, 0, &#123;'view_mode': 'form', 'view_id': ref('&#123;module_name&#125;.&#123;form_view_id&#125;')&#125;)]"/&gt; 2. 在对应的m2m字段上指定视图1&lt;field name="element_ids" context="&#123;'tree_view_ref': '&#123;module_name&#125;.&#123;tree_id&#125;'&#125;"&gt; 简单的总结，就到这里吧，大家如果有更好的方式请分享给我~]]></content>
      <categories>
        <category>Odoo</category>
        <category>XML</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo12的数据库表约束变化时如何更新约束(_sql_constraints)]]></title>
    <url>%2Fbbs.github.io%2FOdoo12%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BA%A6%E6%9D%9F%E5%8F%98%E5%8C%96%E6%97%B6%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E7%BA%A6%E6%9D%9F-sql-constraints%2F</url>
    <content type="text"><![CDATA[两种方式： 1. 覆盖重写举个🌰： 12345678910111213141516# odoo源码酱紫_sql_constraints = [ ('code_and_name', 'UNIQUE(code,name)', _("Code and Name must be unique!")), ]# 现在变成了 code + company 唯一约束# 如果哦我们不介意unique的在数据库中的名称 我们可以酱紫写_sql_constraints = [ ('code_and_name', 'UNIQUE(code,company_id)', _("Code and Company must be unique!")), ]# 即名称相同，直接覆盖 可以取数据库中查看表的unique选项 ![覆盖重写](https://img-blog.csdnimg.cn/20190311140149173.png) 2. 查询删除并新增1234567891011121314151617181920212223242526272829303132333435# odoo源码酱紫(account.account) _sql_constraints = [ ('code_company_uniq', 'unique (code,company_id)', 'The code of the account must be unique per company !') ]# 查询删除并新增酱紫# -*- coding: utf-8 -*-from odoo import _, api, fields, models, modulesfrom odoo.exceptions import ValidationErrorimport logging_logger = logging.getLogger(__name__)class AcountAccountInherit(models.Model): _inherit = 'account.account' @api.model_cr def init(self): # 删除Odoo源码 科目表的约束条件 cr = self.env.cr unique_name = 'account_account_code_company_uniq' table_name = 'account_account' cr.execute("""SELECT 1 from pg_constraint cs JOIN pg_class cl ON (cs.conrelid = cl.oid) WHERE cs.conname=%s and cl.relname=%s""", (unique_name, table_name)) if cr.fetchone(): cr.execute('ALTER TABLE "%s" DROP CONSTRAINT "%s"' % (table_name, unique_name), ) _logger.info('Dropped CONSTRAINT %s@%s', table_name, unique_name) # 新增新约束 _sql_constraints = [ ('code_and_account_structure', 'UNIQUE(code,account_structure_id)', _("Code and account structure must be unique!")), ]]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo12个性化模块覆盖源码字段的翻译(i18n)]]></title>
    <url>%2Fbbs.github.io%2FOdoo12%E4%B8%AA%E6%80%A7%E5%8C%96%E6%A8%A1%E5%9D%97%E8%A6%86%E7%9B%96%E6%BA%90%E7%A0%81%E5%AD%97%E6%AE%B5%E7%9A%84%E7%BF%BB%E8%AF%91-i18n%2F</url>
    <content type="text"><![CDATA[场景当我们有一个字段123# 源码 analytic 模块"""py代码"""code = fields.Char(string='Reference', index=True, track_visibility='onchange') 12345&quot;&quot;&quot;po代码&quot;&quot;&quot;#. module: analytic#: model:ir.model.fields,field_description:analytic.field_account_analytic_account__codemsgid &quot;Reference&quot;msgstr &quot;参考&quot; 现在我们需要将Reference翻译成 “编码参照”1234567891011# 个性化 new_module 模块"""py代码"""# 继承_get_import_cursor方法 将继承模块的翻译替换 启用class IrTranslation(models.Model): _inherit = 'ir.translation' def _get_import_cursor(self): context = self._context.copy() context['overwrite'] = True self = self.with_context(context) return super(IrTranslation, self)._get_import_cursor() 12345&quot;&quot;&quot;po代码 覆盖原翻译&quot;&quot;&quot;#. module: analytic#: model:ir.model.fields,field_description:analytic.field_account_analytic_account__codemsgid &quot;Reference&quot;msgstr &quot;编码参照&quot; 其实这个与我们config文件中的 –i18n-overwrite =&gt; config[‘overwrite_existing_translations’] 的配置内容相同。 这样处理后，我们需要升级我们的个性化模块 new_module ，升级完成后，翻译覆盖成功。值得注意的是：1. 加载翻译不会生效 2. 升级模块后翻译覆盖成功，但是如果再次加载翻译，覆盖的翻译会被还原。 讨论：如何将源码的翻译替换掉，并且还能拿持久化，如果有好的建议请您指点！]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[odoo action页面跳转直接为编辑状态操作]]></title>
    <url>%2Fbbs.github.io%2Fodoo-action%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E7%9B%B4%E6%8E%A5%E4%B8%BA%E7%BC%96%E8%BE%91%E7%8A%B6%E6%80%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[123456789return &#123; &apos;type&apos;: &apos;ir.actions.act_window&apos;, &apos;view_type&apos;: &apos;form&apos;, &apos;view_mode&apos;: &apos;form&apos;, &apos;res_model&apos;: &apos;；module.model_name&apos;, &apos;res_id&apos;: self.id, &apos;context&apos;: self.env.context, &apos;flags&apos;: &#123;&apos;initial_mode&apos;: &apos;edit&apos;&#125;, &#125; 加上这句：‘flags’: {‘initial_mode’: ‘edit’}, Odoo12使用：context[‘form_view_initial_mode’] = ‘edit’ 特别感谢技术提供来源URL]]></content>
      <categories>
        <category>Odoo</category>
        <category>XML</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的坑汇总]]></title>
    <url>%2Fbbs.github.io%2Fhexo%E7%9A%84%E5%9D%91%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[删除hexo工程手动rm -rf hexo工程 后，发现了一个问题，虽然绑定了github page,但是hexo工程的源码并没有了，目前是没发现什么恢复的方式。 推荐大家使用pycharm编写，就算rm -rf 删除了工程，我们可以mkdir 同名hexo工程文件，然后右击文件上选择Local History,找到一个历史点，选择Revert，这时候工程就恢复到了历史点。 推荐使用方式 使用pycharm编辑 使用git仓库管理，定时上传hexo工程代码]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm切换国内源]]></title>
    <url>%2Fbbs.github.io%2Fnpm%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90%2F</url>
    <content type="text"><![CDATA[切换国内源npm install -g cnpm –registry=https://registry.npm.taobao.org cnpm install hexo-cli -g]]></content>
      <categories>
        <category>linux</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PEP8必须学习]]></title>
    <url>%2Fbbs.github.io%2FPEP8%E5%BF%85%E9%A1%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[URL-ChineseURL-English 这些开发规范还是很重要的，必读]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postgresql10持续学习(ing)]]></title>
    <url>%2Fbbs.github.io%2FPostgresql10%E6%8C%81%E7%BB%AD%E5%AD%A6%E4%B9%A0-ing%2F</url>
    <content type="text"><![CDATA[视图 视图是为了避免每次查询都要敲打sql而出现的替代物，它就像一张表，可以存储多个变之间的结构和数据关系。12345-- 学生选课查询create view myView AS select p.name,p.age,c.name from people p,course c where p.id = c.p_id 以后我想查询数据，我只需要select * from myView;就能实现我的整个查询。 外键 可以约束表的插入数据的完整性 事务 事务最重要的一点是它将多个步骤捆绑成了一个单一的、要么全完成要么全不完成的操作 一个事务被数据库系统完成并认可，它就被永久地记录下来且即便其后发生崩溃也不会被丢失 当多个事务并发运行时，每一个都不能看到其他事务未完成的修改 一组被BEGIN和COMMIT包围的语句也被称为一个事务块 保存回滚点 回滚点前的数据依旧存在 回滚点到rollback区间的操作不记录savepoint 回滚点名称rollback to 回滚点名称1234567891011BEGIN;UPDATE accounts SET balance = balance - 100.00WHERE name = 'Alice';SAVEPOINT my_savepoint;UPDATE accounts SET balance = balance + 100.00WHERE name = 'Bob';-- oops ... forget that and use Wally's accountROLLBACK TO my_savepoint;UPDATE accounts SET balance = balance + 100.00WHERE name = 'Wally';COMMIT; 窗口函数 窗口函数主要是用聚集函数的，但是需要部分聚集，相同聚集字段记录放一起进行聚集计算OVER (ORDER BY 字段名 ORDER BY 字段名) 是窗口函数的定义1SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary; 继承123456789CREATE TABLE cities (name text,population real,altitude int -- (in ft));CREATE TABLE capitals (state char(2)) INHERITS (cities); 123SELECT name, altitudeFROM ONLY citiesWHERE altitude &gt; 500; ONLY用于指示查询只在cities表上进行而不会涉及到继承层次中位于cities之下的其他表]]></content>
      <categories>
        <category>Postgresql</category>
      </categories>
      <tags>
        <tag>Postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo12-启动持续分析(ing)]]></title>
    <url>%2Fbbs.github.io%2FOdoo12-%E5%90%AF%E5%8A%A8%E6%8C%81%E7%BB%AD%E5%88%86%E6%9E%90-ing%2F</url>
    <content type="text"><![CDATA[sys.argv:第一个参数是执行的文件全路径，后面的参数是执行文件时的参数 OptionContainer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152抽象类类属性： standard_option_list - 一个列表，用于列出公共的选项，一般在继承的子类中实现 实例属性： option_list： 选项对象列表 _short_opt：&#123;string:Opthon&#125; 简写 _long_opt：&#123;string:Opthon&#125; 全称 defaults：&#123;string:any&#125; 其他默认指令映射方法： __init__: self._create_option_list() self.option_class = option_class# 选项类 self.set_conflict_handler(conflict_handler)# 冲突类 self.set_description(description) # 描述 _create_option_mappings: # 初始化三个实例属性 self._short_opt = &#123;&#125; # single letter -&gt; Option instance self._long_opt = &#123;&#125; # long option -&gt; Option instance self.defaults = &#123;&#125; # maps option dest -&gt; default value _share_option_mappings： # 设置三个实例属性 set_conflict_handler： # 设置冲突处理 参数： handler - error/resolve conflict_handler = handler set_description： # 设置描述 get_description： # 获取描述 def destroy(self): # 三个实例参数销毁 &quot;&quot;&quot;see OptionParser.destroy().&quot;&quot;&quot; del self._short_opt del self._long_opt del self.defaults _check_conflict： 验证当前选项是否已经存在 add_option： 单个选项添加 add_options： 参数： option_list 批量选项添加 OptionParserodoo.tools.config.parse_config(args)是什么作用？ odoo-bin import odoo 包引入，参数初始化 odoo.cli.main()启动服务 command.py args - 拿到对应的启动参数 commands - 可调用函数集合 o - 实例化Server类 o.run(args) - 启动服务 cli/server.py/main(args) cli/server.py(只提及主要部分) check_root_user() 检查当前操作机器用户不能为root 限制权限 odoo.tools.config.parse_config(args)# 加载–config文件内容到全局变量 或者创建一个./config文件 check_postgres_user()#post的用户不能是postgres report_configuration()# 打印配置信息 config 就是当前加载过config文件 系统的配置参数实例 config - pidfile文件存在的话，如果args参数第二个为evented，打开文件存储主线程相关 odoo.service.server.start启动wsgi load_server_wide_modules 加载服务器预支模块base、web initialize_sys_path()初始化配置的系统路径addons_path 挂载钩子 sys.meta_path 和 hooked=True]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python统计文件行数]]></title>
    <url>%2Fbbs.github.io%2FPython%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[basedirs = [‘/Users/tc/code/odoo8/hrp’]filelists = [] 指定想要统计的文件类型whitelist = [‘xml’, ‘py’, ‘js’, ‘css’] 遍历文件, 递归遍历文件夹中的所有12345678910111213def getFile(basedir): global filelists local_filelists = [] for parent,dirnames,filenames in os.walk(basedir): #for dirname in dirnames: # getFile(os.path.join(parent,dirname)) #递归 for filename in filenames: ext = filename.split('.')[-1] #只统计指定的文件类型，略过一些log和cache文件 if ext in whitelist: local_filelists.append(os.path.join(parent,filename)) filelists.append(os.path.join(parent,filename)) return local_filelists 统计一个文件的行数def countLine(fname): count = 0 for file_line in open(fname).xreadlines(): if file_line != ‘’ and file_line != ‘\n’: #过滤掉空行 count += 1 return countif name == ‘main‘ : startTime = time.clock() all_line = 0 for basedir in basedirs: local_filelists = getFile(basedir) totalline = 0 for filelist in local_filelists: totalline = totalline + countLine(filelist) all_line += totalline print str(basedir.split(“/“)[-1])+’,’,totalline print ‘ =&gt; ALL LINES:’+str(all_line)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-Xmlrpc]]></title>
    <url>%2Fbbs.github.io%2FOdoo-Xmlrpc%2F</url>
    <content type="text"><![CDATA[XMLRPC 看例子1234外部调用url:http://localhost:8069/xmlrpc/2/objectmethod:postapplication/xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--XML请求报文结构--&gt;&lt;methodCall&gt; &lt;!-- used to call methods of odoo models --&gt; &lt;methodName&gt;execute&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;!--数据库名称--&gt; &lt;value&gt;&lt;string&gt;zocx919&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;!--登录用户ID--&gt; &lt;value&gt;&lt;int&gt;用户ID&lt;/int&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;!--用户登录密码--&gt; &lt;value&gt; &lt;string&gt;zochrp&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;!--调用方法存在的模型--&gt; &lt;value&gt; &lt;string&gt;account.asset.asset&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;!--调用方法的名称--&gt; &lt;value&gt; &lt;string&gt;get_datas&lt;/string&gt; &lt;/value&gt; &lt;/param&gt; &lt;!--传入方法的参数--&gt; &lt;param&gt; &lt;array&gt; &lt;struct&gt; &lt;member&gt; &lt;!--Key 不用写string 否则报错--&gt; &lt;name&gt;name&lt;/name&gt; &lt;!--Value--&gt; &lt;value&gt;&lt;string&gt;LiMing&lt;/string&gt;&lt;/value&gt; &lt;/member&gt; &lt;/struct&gt; &lt;value&gt;&lt;int&gt;1&lt;/int&gt;&lt;/value&gt; &lt;/array&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; 123456789# 响应方法class HrpZocAccountAssetAsset(models.Model): _inherit = "account.asset.asset" @api.model def get_datas(self, vals): print 'ok............' return vals # 返回值 要拼接成 字典 类型， xmlrpc自动解析返回xml格式响应报文 分析1、调用的数据中记得必须使用的是object2、XML请求报文中 array标签类似于python中的列表，struct标签类似于python中的字典，struct结构中只能出现格式: 1234&lt;member&gt; &lt;name&gt;xxx&lt;/name&gt; &lt;value&gt;xxx&lt;/value&gt;&lt;/member&gt; 3、python代码中需要定义特定的接收方法，并且返回一个数据字典 其他暂无]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-Jsonrpc]]></title>
    <url>%2Fbbs.github.io%2FOdoo-Jsonrpc%2F</url>
    <content type="text"><![CDATA[JSONRPC 看例子1234外部调用url:http://localhost:8069/jsonrpcmethod:postapplication/json 12345678910111213&#123; "jsonrpc": "2.0", "method": "call", "params": &#123; "service": "object", "method": "execute", "args": ["数据库名称", 登录用户ID, "登录用户密码", "模型", "方法", [ '参数及合' ] ] &#125;&#125; 123456789# 响应方法class HrpZocAccountAssetAsset(models.Model): _inherit = "account.asset.asset" @api.model def get_datas(self, vals): print 'ok............' return vals # 返回值 要拼接成 字典 类型响应报文]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-QWeb]]></title>
    <url>%2Fbbs.github.io%2FOdoo-QWeb%2F</url>
    <content type="text"><![CDATA[Base Template /static/src/xml/*.xml 定义模板。 openerp.py的qweb中注册*.xml文件 JS加载模板(两种) QWeb.render(模板名称) template: “模板名称” JS调用模板传参(两种) QWeb.render(模板名称,参数字典) template接收显示\ template: “模板名称” 通过init方法初始化参数,通过this传递(注意parent参数和继承_super方法必须使用)1234init: function(parent) &#123; this._super(parent); this.name = "Mordecai"; &#125;, template接收显示\]]></content>
      <categories>
        <category>Odoo</category>
        <category>Qweb</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
        <tag>Qweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-报表]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E6%8A%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[pdf报表PDF报表结构 一个XML数据配置文件 一个py文件 Odoo原生的报表通过HTML或者QWeb定义，可以通过Qweb控制流工具，使用wkhtmltopdf来注册pdf。定义一个报表的主要需要定义1.报表 2.报表模板 3.可以个性化格式 4.可以客户化class来为报表的数据服务 Report 报表都需要定义一个 report_action： 可以通过一个标签来定义 report_action.格式定义： id - 是report_action的外部ID(ir_model_data可查) name(必输) - 数据库中的report_name 用于对应报表模板的外部ID file - 数据库中的report_file 与name相同 string - PDF报表名称 action的下拉名称 model(必输) - 报表放那个model的界面上 report_type(必输) - 报表类型 目前我们认为它只有两种打印PDF的qweb-pdf、和打印HTML的qweb-html. report_name - 报表名称 输出报表的名字 groups - 组权限控制 哪个对应的用户组能够触发报表操作 attachment_use - bool(true/false) 如果设置成True则会将打印的报表以附件attachment的形式存储在系统的附件系统中，用于一次使用，需要测试。 attachment - python逻辑赋值表达式，用来定义附件存储的文件名称 可使用一定的逻辑判断赋值。 paperformat - 默认定义为公司下的纸张格式 如果有特殊需要可以自定义纸张格式。 1234567891011&lt;report id="account_invoices" model="account.invoice" string="Invoices" report_type="qweb-pdf" name="account.report_invoice" file="account.report_invoice" attachment_use="True" attachment="(object.state in ('open','paid')) and ('INV'+(object.number or '').replace('/','')+'.pdf')"/&gt; Report Template 报表模板中call外部布局样式，它将添加默认的报表头和报表尾。PDF报表体江北包含在标签中，template的外部id必须符合报表定义规则，从Qweb模板中，能够通过docs访问对象包含的所有字段。 报表中有一些特定的变量: docs - 当前报表的记录集合(数据) doc_ids - 当前报表的记录集合的ids列表 doc_model - docs包含的数据记录来源model time - 从python标准库中引用的time对象 user - 打印报表的用户 res_company - 当前打印报表用户对应公司 如果需要访问其他模型的记录集，可以关注后续的客户话报表。 Translatable Templates(可翻译的模板)如果需要根据业务伙伴的语言来打印对应语言格式的报表，需要定义两个模板。 主报表模板 可翻译的文件 可以在主报表模板中加入t-lang属性设置语言来直接调用翻译文件，如果需要对使用的字段等进行翻译，可以对字段附属的对象传入相应的context参数，使对象变的可翻译。1如果没有想要翻译，最好不写，因为写入会重读记录，影响打印效率 1234567891011121314151617181920212223242526&lt;!-- Main template --&gt;&lt;template id="report_saleorder"&gt; &lt;t t-call="web.html_container"&gt; &lt;t t-foreach="docs" t-as="doc"&gt; &lt;t t-call="sale.report_saleorder_document" t-lang="doc.partner_id.lang"/&gt; &lt;/t&gt; &lt;/t&gt;&lt;/template&gt;&lt;!-- Translatable template --&gt;&lt;template id="report_saleorder_document"&gt; &lt;!-- Re-browse of the record with the partner lang --&gt; &lt;t t-set="doc" t-value="doc.with_context(&#123;'lang':doc.partner_id.lang&#125;)" /&gt; &lt;t t-call="web.external_layout"&gt; &lt;div class="page"&gt; &lt;div class="oe_structure"/&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6"&gt; &lt;strong t-if="doc.partner_shipping_id == doc.partner_invoice_id"&gt;Invoice and shipping address:&lt;/strong&gt; &lt;strong t-if="doc.partner_shipping_id != doc.partner_invoice_id"&gt;Invoice address:&lt;/strong&gt; &lt;div t-field="doc.partner_invoice_id" t-options="&#123;&amp;quot;no_marker&amp;quot;: True&#125;"/&gt; &lt;...&gt; &lt;div class="oe_structure"/&gt; &lt;/div&gt; &lt;/t&gt;&lt;/template&gt; 解释一下:主报表模板调用附加context属性t-lang为doc.partner_id.lang 的翻译模板，这样就会被对应的语言渲染。这样的话，报表就会打印成对应业务伙伴语言的报表。如果只需要转换报表体内容而不动报表头/尾部分，可以：1&lt;t t-call="web.external_layout" t-lang="en_US"&gt; Barcodes(条形码)可以很方便的借助Qweb的语法将条形码嵌入到模板中1&lt;img t-att-src="'/report/barcode/QR/%s' % 'My text in qr code'"/&gt; 可以传递一些参数：12&lt;img t-att-src="'/report/barcode/? type=%s&amp;value=%s&amp;width=%s&amp;height=%s'%('QR', 'text', 200, 200)"/&gt; Useful Remarks(有效的语法) Report Template可以使用Twitter Bootstrap 和 FontAwesome类来渲染。 本地CSS可以在Template中使用。 可以通过继承主报表样式来插入到我们的css中。 123456789&lt;template id="report_saleorder_style" inherit_id="report.style"&gt; &lt;xpath expr="."&gt; &lt;t&gt; .example-css-class &#123; background-color: red; &#125; &lt;/t&gt; &lt;/xpath&gt;&lt;/template&gt; Paper Format(纸张格式)报表格式是report.paperformat对象的记录，它们经常包括如下几个参数: name(必输) - 可标识样板格式的简要名称 description - 对样板简短的介绍 format - 预定义格式A0-A9 B0-B9 Legal Letter Tabloid… 默认是A4，如果定义了这个参数将无法使用个性化的格式。 dpi - 输出的DPI 默认为90 margin_top, margin_bottom, margin_left, margin_right - 边距大小默认单位mm page_height , page_width - 页面尺寸 默认单位mm orientation - Landscape 或者 Portrait header_line - 布尔值 是否显示头行 header_spacing - 头空间 默认单位mm 123456789101112131415&lt;record id="paperformat_frenchcheck" model="report.paperformat"&gt; &lt;field name="name"&gt;French Bank Check&lt;/field&gt; &lt;field name="default" eval="True"/&gt; &lt;field name="format"&gt;custom&lt;/field&gt; &lt;field name="page_height"&gt;80&lt;/field&gt; &lt;field name="page_width"&gt;175&lt;/field&gt; &lt;field name="orientation"&gt;Portrait&lt;/field&gt; &lt;field name="margin_top"&gt;3&lt;/field&gt; &lt;field name="margin_bottom"&gt;3&lt;/field&gt; &lt;field name="margin_left"&gt;3&lt;/field&gt; &lt;field name="margin_right"&gt;3&lt;/field&gt; &lt;field name="header_line" eval="False"/&gt; &lt;field name="header_spacing"&gt;3&lt;/field&gt; &lt;field name="dpi"&gt;80&lt;/field&gt;&lt;/record&gt; 客户化报表报表model有一个get_html方法，就是通过report.{module.report_name}来寻找客户化报表model，如果找到的话，将使用找到的这个类来调用Qweb引擎,否则就调用默认方法。如果希望客户化一个包含了各种项的报表模板，就可以定义这个model，重写render_html方法，并且在docargs列表中传递数据。 报表都可以在web页面上显示可以通过例如:http:///report/html/sale.report_saleorder/38http:///report/pdf/sale.report_saleorder/38如上方式访问html/pdf的报表 Odoo11 PDF报表实例流程1.创建一个ir.actions.report对象12345678&lt;report string="界面打印下拉框处显示的文字" id="ir_model_data表中创建的数据记录name 其实就是外部id①" model="报表绑定的model 在哪个界面上显示" report_type="报表类别/qweb-pdf" name="hrp_asset.report_asset_transfer_application" file="hrp_asset.report_asset_transfer_application"/&gt; XML文件中 首先介绍一下XML文件中的基础格式: 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;openerp&gt; &lt;data&gt; &lt;/data&gt;&lt;/openerp&gt; 初始化一个report数据项: 12345678&lt;report string="界面打印下拉框处显示的文字" id="ir_model_data表中创建的数据记录name 其实就是外部id①" model="报表绑定的model 在哪个界面上显示" report_type="报表类别/qweb-pdf" name="hrp_asset.report_asset_transfer_application" file="hrp_asset.report_asset_transfer_application"/&gt; 对report项绑定一个数据模板，paperformat_id来自于report.paperformat: 123&lt;record id="ir_model_data表中创建的数据记录name 其实就是外部id①" model="ir.actions.report.xml"&gt; &lt;field name="paperformat_id" ref="hrp_base.paperformat_horizontal_A4"/&gt;&lt;/record&gt; 注:这里的paperformat可以自行定义样式]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-Excel下载]]></title>
    <url>%2Fbbs.github.io%2FExcel%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[excel下载结构class inherit_report_xls(report_xls)①class inherit_rml_parse(report_sxw.rml_parse)② 第一个python类class继承report_xls,用于控制界面样式调整，主要是重写继承类report_xls中的generate_xls_report方法。继承report_xls类的class初始化。 第二个python类class用于基础数据获取与传递功能。就是文中的_p 一个odoo类class用于使用odoo的ORM或方法定义获取对应的数据集合。 12另外:大多数报表都有相应的弹出界面选择功能，对应的可以使用这个class去定义一些弹出框的选择字段，用作筛选条件。总之，这个class就是用于各种数据逻辑处理的模型。 实例化第一个report_xls类，用于注册使用。inherit_report_xls(‘report.report_name’③,’报表定义的model’④,’inherit_rml_parse’⑤) 一个XML,用于定义form弹窗相关的Acion、Form、Report与模型进行绑定 流程： 123456789101112实现流程： 创建report_xls的继承类和report_sxw.rml_parse的继承类。 实例化report_xls继承类 创建odoo的class定义字段、写各种方法(例如获取数据下载报表方法print_report，打开报表选择页面的action方法等)。 创建XML来个性化弹出框与选择条件，定义一个print_report按钮，定义一个连接数据对象。 操作流程: 点击报表菜单 - 弹出一个form界面(可能有参数选择) - 完成后点击打印按钮(print_report) - 报表打印 另外:12345return &#123; &apos;type&apos;: &apos;ir.actions.report.xml&apos;, &apos;report_name&apos;: &apos;nov.account.journal.xls&apos;, &apos;datas&apos;: datas, &apos;context&apos;:self.env.context&#125; 直接return调用report_name的报表，有时候回使用一下context传点个性化的参数。 12345678&lt;record id="action_import_move_line_details_xls" model="ir.actions.report.xml"&gt; &lt;field name="name"&gt;Import Move Line Details&lt;/field&gt; &lt;field name="model"&gt;hrp.account.gl.account.move&lt;/field&gt; &lt;field name="type"&gt;ir.actions.report.xml&lt;/field&gt; &lt;field name="report_name"&gt;import.move.line.details.xls&lt;/field&gt; &lt;field name="report_type"&gt;xls&lt;/field&gt; &lt;field name="auto" eval="False"/&gt; &lt;/record&gt; 重要的是model，report_name,report_type： model目前我是默认写的objects挂载的模型，和注册中的model名称相同。(后续了解ir.act.report.xml看看model是用来干啥的) report_name:python代码中return调用的xls，其实就是ir.act.report.xml的唯一属性。 report_type:是报表支持的类型，qweb-pdf、qweb-html、pdf、xls、xlsx等。 1234&apos;name&apos;: &#123; &apos;header&apos;: [1, 25, &apos;text&apos;, _render(&quot;_(&apos;Name&apos;)&quot;)], &apos;lines&apos;: [1, 0, &apos;text&apos;, _render(&quot;line[&apos;name&apos;] or &apos;&apos;&quot;)], &apos;totals&apos;: [1, 0, &apos;text&apos;, None]&#125;, ’text’那个位置是用来判断初始化的 ‘’ 123import_move_line_details_xls(&apos;report.import.move.line.details.xls&apos;, &apos;hrp.account.gl.account.move&apos;, parser=import_move_line_details_xls_parser) 格式：report_xls继承类(‘xls名称’,’objects挂载模型’,’parser对象’)objects挂载模型的意思是，我们excel的数据取值是通过对应的记录来取值的，这里必须选择取数逻辑的model.我们可以发现它直接定位到了我们打印的单据数据，当然这是在form上或者通过form的一个按钮打开一个Transation的model来打印报表的，如果是那种放在’更多’中的批量数据打印，我们还需要相应的做一些context的处理。 逐步理解中…]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo8-JS小记]]></title>
    <url>%2Fbbs.github.io%2FOdoo8-JS%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JS - 基础入门理解 定义ir.action.client 带tag 与绑定的菜单对象123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;openerp&gt; &lt;data&gt; &lt;record id="widget_menu_action" model="ir.actions.client"&gt; &lt;field name="name"&gt;Widget Menu Action&lt;/field&gt; &lt;field name="tag"&gt;tps_widget.widget_menu&lt;/field&gt; &lt;/record&gt; &lt;menuitem id="tps_widget_top_menu" name="Widget Top Menu" sequence="10"/&gt; &lt;menuitem id="tps_widget_sub_menu" name="Widget Sub Menu" parent="tps_widget_top_menu" sequence="10"/&gt; &lt;menuitem id="tps_widget_func_menu" name="Widget Func Menu" parent="tps_widget_sub_menu" action="widget_menu_action" sequence="10"/&gt; &lt;/data&gt;&lt;/openerp&gt; 定义一个js文件 - extend_widget.js 包含content： 12345678910111213openerp.tps_widget = function (instance, local) &#123; var _t = instance.web._t, _lt = instance.web._lt; var QWeb = instance.web.qweb; local.MyWidget = instance.Widget.extend(&#123; start: function () &#123; console.log("load Mywidget.") &#125; &#125;); //第一个参数是tag 第二个参数是widget的完整地址 instance.web.client_actions.add('tps_widget.widget_menu', 'instance.MyWidget');&#125; 引入js文件，定义一个xmlviews/xxx_template.xml 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;openerp&gt; &lt;data&gt; &lt;template id="assets_backend" name="tps_widget" inherit_id="web.assets_backend"&gt; &lt;xpath expr="." position="inside"&gt; &lt;script type="text/javascript" src="/tps_widget/static/js/extend_widget.js"&gt;&lt;/script&gt; &lt;/xpath&gt; &lt;/template&gt; &lt;/data&gt;&lt;/openerp&gt; 注意这里暂时没有py文件，但是xml文件需要在openerp.py中注册[定义菜单的xml 和 引入js的xml]。 用法 this this.$el ob.appendTo(this.$el) this.getParent().$el this.getChildren()[0].$el JS - 挂件o2m_uniqueo2m中的主数据字段，每张单据只能选一次，唯一性处理。 many2many_tagm2m单据数据排列组合不可重复]]></content>
      <categories>
        <category>Odoo</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本操作指令笔记]]></title>
    <url>%2Fbbs.github.io%2Fgit%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本操作基本命令git clone url git checkout -b T1 git checkout T1git checkout . git branch git branch -D T1 git branch -m T1 git status git diff git add . git commit [-m ‘message’] git push origin T1 git fetch origin T1:T1 git merge –no-ff master-branch git reset –mixed HEAD^ git commit –amend 可以对上一次的提交做修改 git clean -df 代码冲突解决流程 git checkout test git pull origin test git checkout 任务分支 git checkout -b 任务分支-1 git merge –no-ff test 代码中解决冲突 git add . git commit git push origin 任务分支-1 gitlab上合并 任务分支-1 到 test]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-翻译]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[ir_translation简章[字段]langsrcnameres_idmodulestatecommentsvaluetype 几种翻译的加载方式普通按钮翻译 直接加载翻译 注:(XML上的按钮翻译旧源不认识下划线_) 报表翻译report:report_name:0 直接加载翻译 菜单翻译重启 - 升级 - 加载翻译 字段翻译直接加载翻译 ### 例子： 12345#. module: dy_fin_stock#: model:ir.model.fields,field_description:dy_fin_stock.field_dy_fin_create_move_stock_wizard__summary_rule_id#: model:ir.model.fields,help:dy_fin_stock.field_dy_fin_create_move_stock_wizard__summary_rule_idmsgid &quot;Summary Rule&quot;msgstr &quot;合并规则&quot; code翻译直接加载翻译 module信息翻译手动删除所有翻译，重新加载翻译 xxx_data.xml文件翻译例子：123456789#. module: dy_fin_stock#: model:res.groups,name:dy_fin_stock.account_move_linkmsgid &quot;Account Move Link Group&quot;msgstr &quot;查看凭证权限组&quot;#. module: dy_fin_stock#: model:res.groups,comment:dy_fin_stock.account_move_linkmsgid &quot;Account Move Link！&quot;msgstr &quot;拥有库存移动凭证状态查看权限！&quot; 解释1234#. module: [module]#: model:[model],[field_name]:[module].[external_id]msgid &quot;翻译源&quot;msgstr &quot;翻译值&quot; 重写源码的字段翻译直接在继承的小模块i18n中重写 module:写原来的或但钱模块的都可以 最后在数据库中会被转换成小模块的 例如:hrp_account翻译的显示值使用的是id最大的那一个匹配值1234#. module: account#: selection:account.invoice,state:0msgid &quot;Open&quot;msgstr &quot;已审批&quot;]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo,XML]]></title>
    <url>%2Fbbs.github.io%2FOdoo-XML%2F</url>
    <content type="text"><![CDATA[xmldata文件初始化中的知识点1.结构123456789&lt;openerp&gt; &lt;data&gt; &lt;record&gt; &lt;filed&gt;&lt;/filed&gt; &lt;/record&gt; &lt;/data&gt; &lt;data&gt;...&lt;/data&gt; ...&lt;/openerp&gt; 属性篇attrs(公共属性) invisible:影藏组件。 required:组件必须有值。 readonly:组件只读不可编辑(onchange过来的值不会被保存，需要在create/write方法中加入到vals中，或者开发个性化readonly存储挂件，例如:readonly_by_pass)。 如果后面的条件是类似domain形式的，那么[(A,’OP’,B)]中，A是一个可选的字段，但是这个字段不能像py中的domain，它不能使用A.b这样的字段引用关系。所以如果我们需要把这样的A.b字段在我们的模型中定义一个related字段，并把它放在xml中，这就是我们所谓的辅助字段。&gt; noupdate - forcecreate noupdate - 属于data的标签属性 forcecreate - 属于record的标签属性123456789作用： noupdate主要用于data块里的record记录初始化，这些记录都会有一个ExtendID，也就是record上所谓的id,在ir_module_data上唯一。 noupdate的主要功能是初始化一遍数据，如果之后对XML数据定义修改了，再升级，这些数值是不会变化的，依旧保持第一次上来的样子。 但是如果你在界面删除了初始化的数据，那么下次升级模块，这些数据就会以修改后的XML数据为基础创建。 如果只想数据第一次初始化进来，以后不改变，并且就算被删掉后，希望升级后也不要出现，那么就给对应的record记录上， 写forcecreate=&apos;false&apos;,这样就能保证模块安装初始化上来的数据，不会被任何情况修改更新，删除后不再创建。 forcecreate必须绑定在noupdate中才生效,noupdate保持已有数据不更新，forcecreate保证数据删除，升级不创建。如果删除了noupdate块中data文件初始化的数据记录，然后你重新更新它不重置，你可以看一下ir_module_data表，对应的data块外部id记录中，noupdate=True,把那条记录删除再升级就出来了。 options(m2o关系字段属性) no_create_edit:关系字段不允许在当前界面创建这个字段对应的模型记录。 no_create:不允许直接在当前界面创建字段对应的模型记录(从代码中看no_create_edit和no_create逻辑一样)。 no_open:不允许打开关系字段后面对应的单据。 注意：最好用no_open:True/False，不要过度使用no_open:’0’/‘1’,经过测试[‘0’ == ‘1’ == True] options(o2m关系字段属性) no_edit_no_open:关系字段不允许在当前界打开对应记录的form界面。 批量添加 1.batch_add(新开发js挂件非原生) 直接在o2m的XML字段属性上挂载batch_add=&quot;true&quot;即可。 2.ids_select 这个比较复杂: 1.首先在py文件的头行结构中，定义一个头字段ids_select,字段属性定义如下: ids_select = fields.Char(string=&apos;ids&apos;, help=&apos;This id is to get ids of multiple select of one2many&apos;) 2.然后再XML的头部放入ids_select字段，可影藏，字段定义如下: &lt;field name=&quot;ids_select&quot; class=&quot;oe_o2mx&quot; invisible=&quot;1&quot; on_change=&quot;updateLines(ids_select,o2m_filed,context)&quot;/&gt; 3.绑定对应的o2m字段，将挂件 widget=&quot;o2mx&quot; 加到XML字段属性定义中。对应需o2m_filed的tree上要批量添加的主体字段(m2o_field)挂载 multiple_selection=&quot;true&quot; 属性。 4.对ids_select定义on_change的方法updateLines进行逻辑处理: - 通用结构: if not ids_select: return 0 selected_ids = ids_select.split(&apos;,&apos;) if len(o2m_filed) == 1: change_line = False o2m_filed = self.o2m_filed.browse(o2m_filed[0][2]) else: change_line = True o2m_filed = map(lambda x: x[2], filter(lambda x: x[2], o2m_filed)) res = [] old_value = [] add_ids = [] line_number = 0 for line in o2m_filed: line_number += 1 m2o_field = change_line and line[&apos;m2o_field&apos;] or line.m2o_field.id old_value.append({ &apos;line_number&apos;:line_number, &apos;m2o_field&apos;: m2o_field, &apos;field1&apos;: field1, &apos;field2&apos;: field2, &apos;field3&apos;: field3, ... }) add_ids.append(m2o_field) for id in selected_ids: line = self.env[&apos;selected_ids_model&apos;].browse(int(id)) if int(id) not in add_ids: line_number += 1 res.append({ &apos;line_number&apos;: line_number, &apos;m2o_field&apos;: line.m2o_field.id or False, &apos;field1&apos;: line.field1, &apos;field2&apos;: line.field2, &apos;field3&apos;: line.field3, ... }) if res: return {&apos;value&apos;: {&apos;invoice_detail_ids&apos;: old_value + res}} - 普通 自动递增 递增间隔 最开始的值 Domain XML定义的domain会覆盖字段定义的domain ir.actions.act_window[参数] src_model： 来源模型这个动作应该放在哪个可见的对象可选模型名称(绑定到哪个模型上显示) res_model： 目标模型在视图窗口中打开的对象的模型名称(打开的wizard模型) context: search_default_字段名称: display_filter:在wizard的action上定义如: context=”{‘display_filter’:’invoice_form_view’}”在对应的绑定模型中的context中写入如：context=”{‘invoice_form_view’:1’}”对应绑定的action在限制了view_id,那么这个wizard就唯一绑定在了这个对应的视图上,同模型的其他视图上不显示(一模型多菜单多视图模式)。 execute_method:在wizard的action上定义如: context=”{‘execute_method’:’invoice_execute_method’}”触发action时会直接执行invoice_execute_method方法，但是执行了这个方法就不会直接跳转视图了，你需要在执行的方法中return跳转视图的action。 ‘clear_breadcrumbs’ ‘clear_breadcrumbs’:True可以在视图上隐藏列标题。 res_model: 目标模型 src_model: 原始模型 views: 定义视图类别引用ref view_id: 定义默认打开视图引用ref ir.actions.act_window.view 此模型实际是view_ids的绑定模型,可以通过初始化act_window的view_ids挂在属性值,来控制多个菜单公用一个model,但是打开的是对应的tree、form、search等模型。 1.定义一个action12345678910&lt;record model="ir.actions.act_window" id="hrp_payment_preparation_action"&gt; &lt;field name="name"&gt;Payment Preparation&lt;/field&gt; &lt;field name="res_model"&gt;hrp.payment.request&lt;/field&gt; &lt;field name="view_type"&gt;form&lt;/field&gt; &lt;field name="view_mode"&gt;tree,form&lt;/field&gt; &lt;field name="search_view_id" ref="hrp_payment_preparation_search"/&gt; &lt;field name="domain"&gt;[('state','in',['approved','paying','paid'])]&lt;/field&gt; &lt;field name="context"&gt;&#123;'readonly_by_pass':['company_id','total_amount','invoice_detail_ids','supplier_id','supplier_category_id', 'invoice_date','date_due','payment_method_id','original_amount','open_amount']&#125;&lt;/field&gt;&lt;/record&gt; 2.在action上绑定对应类型的视图外部引用对象1234567&lt;!--供应商预付款申请界面tree视图指定--&gt;&lt;record id="hrp_payment_preparation_tree_view" model="ir.actions.act_window.view"&gt; &lt;field eval="1" name="sequence"/&gt; &lt;field name="view_mode"&gt;tree&lt;/field&gt; &lt;field name="view_id" ref="hrp_payment_preparation_tree"/&gt; &lt;field name="act_window_id" ref="hrp_payment_preparation_action"/&gt;&lt;/record&gt; 1234567&lt;!--供应商预付款申请界面form视图指定--&gt;&lt;record id="hrp_payment_preparation_form_view" model="ir.actions.act_window.view"&gt; &lt;field eval="2" name="sequence"/&gt; &lt;field name="view_mode"&gt;form&lt;/field&gt; &lt;field name="view_id" ref="hrp_payment_preparation_form"/&gt; &lt;field name="act_window_id" ref="hrp_payment_preparation_action"/&gt;&lt;/record&gt; 3.这时候就算一个model上有多个tree视图、多个form视图,甚至是多个search视图等,只要绑定好就会直接打开对应的视图界面,不会打开错咯. 4.如果出现记录单据被通过M2O字段链接的形式跳转过去，那么很可能出现错误，因为点击事件调用了get_formview_action方法，默认获取对应类型视图的view界面，为了在这种情况下不出现错误，我们必须重写get_formview_action方法，提供正确的return导向，也许这里是用的odoo7的写法，在新写法中，我们通过封装@api.v7装饰器，来重载方法，达到我们的目的。]]></content>
      <categories>
        <category>Odoo</category>
        <category>XML</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-onchange的动态domain]]></title>
    <url>%2Fbbs.github.io%2FOdoo-onchange%E7%9A%84%E5%8A%A8%E6%80%81domain%2F</url>
    <content type="text"><![CDATA[onchange的动态domainOnchange函数可以返回一个字典1234567891011121314on_change in OpenERP has 3 possible values returned finally in a dictionary or a &#123;&#125; .1: The value dictionary i.e &#123;field1:value1,field2:value2&#125;2: The domain dictionary i.e &#123;field1:domain1&#125;3: The warningSyntax:res = &#123;&apos;value&apos;:&#123;&#125;,&apos;domain&apos;:&#123;&#125;,&apos;warning&apos;:&apos;Warning Message&apos;&#125;According to your case add this to the return dictionary.&#123;&apos;domain&apos;:&#123;&apos;partner_id&apos;:[(&apos;customer&apos;,&apos;=&apos;,True)]&#125;&#125; 通过[1]我们可以改变界面上的数值,通过[2]我们可以改变界面取值的域(动态domain),通过[3]可以定义一个警告信息]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-后台任务]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[后台任务目前后台任务分为三种: 自动化任务12345678910111213# - 获取cron_job对象hrp_cron_job_obj = self.env['hrp.cron.job']# - 定义延时执行的时间cron_job_date = fields.Datetime.to_string(datetime.now() + timedelta(seconds=30))# - 直接执行不走cron_job的方法(前期测试使用)# self.create_asset_acceptance_account_move(args)# - 延时凭证生成的方法 必须有需要生成的数据项 这里args如果没有数据 也同样会被封装成 元组|所以需要做一个判断if len(args) &gt; 0 and len(args[0]) &gt; 0: hrp_cron_job_obj.run_by_cron(_("Create Asset Receiving Account Move"),# 自动化任务名称 'hrp.asset.receiving.application',# 自动化任务需要调用的方法所在model 'create_asset_acceptance_account_move',# 方法名 [args],# 参数 date_created=cron_job_date)# 延时时间 分析一下方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def run_by_cron(self, name, model, function, args, priority=10, user_id=False, date_created=False): &quot;&quot;&quot; name - 自动化任务名称 model - 执行方法模型 function - 执行的方法名称 args - 参数 priority - 优先级 user_id - 执行用户 date_created - 开始执行时间 &quot;&quot;&quot; # - 如果没有配置时间 默认立即创建启动执行 if not date_created: date_created = fields.Datetime.now() # - 如果没有执行用户 默认当前登录用户 if not user_id: user_id = self.env.user.id # - 解析参数 这里的参数最好的格式是一个列表传入 args = [repr(arg) for arg in args] # - 创建一个自动化任务 self.create(&#123; &apos;name&apos;: name, &apos;model&apos;: model, &apos;function&apos;: function, &apos;args&apos;: &apos;(%s,)&apos; % (&apos;, &apos;.join(args)), &apos;date_created&apos;: date_created, &apos;user_id&apos;: user_id, &apos;priority&apos;: priority, &#125;) # 在自动化任务的create方法中，直接创建了ir.cron记录: @api.model def create(self, vals): # 创建ir_cron ir_cron_obj = self.env[&apos;ir.cron&apos;] res = super(HrpCronJob, self).create(vals) ir_cron = &#123; &apos;name&apos;: vals[&apos;name&apos;], &apos;active&apos;: True, &apos;user_id&apos;: vals[&apos;user_id&apos;], &apos;priority&apos;: vals[&apos;priority&apos;], &apos;interval_type&apos;: &apos;minutes&apos;, &apos;nextcall&apos;: vals[&apos;date_created&apos;], &apos;numbercall&apos;: 1, &apos;doall&apos;: True, &apos;model&apos;: vals[&apos;model&apos;], &apos;function&apos;: vals[&apos;function&apos;], &apos;args&apos;: vals[&apos;args&apos;], &apos;hrp_cron_job_id&apos;: res.id, &#125; ir_cron_obj.create(ir_cron) return res 队列任务 并发管理器]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[name_get]]></title>
    <url>%2Fbbs.github.io%2Fname-get%2F</url>
    <content type="text"><![CDATA[数据筛选通常我们使用的数据筛选，可能是通过某一个字段A关联的字段范围，来控制B字段的取值，常见的方式就是以添加compute字段的m2m辅助字段来限制B字段的取值范围。这样可能会因为辅助字段上存在_id或者_ids的字段，而使得前台界面加载几十次对应的name_get而转圈。替换方式，去掉辅助字段，在需要被限制字段的XML视图定义中加入相应的context，然后在相应的name_search方法中，获取context，通过中间传入的参数进行数据获取判断后拼接domain，使得界面的值域被修正。例如:1234&lt;field name="partner_id" options="&#123;'no_create_edit':'1','no_create':'1','no_open':'1'&#125;" attrs="&#123;'required':[('partner_force_analytic','=',True)]&#125;" context="&#123;'display_name_and_code':True，'account_id':account_id&#125;"/&gt; 123456789101112131415161718192021222324252627282930313233@api.modeldef name_search(self, name='', args=[], operator='ilike', limit=100): # 如果业务伙伴是通过科目上的业务伙伴核算限制范围的话 我们可以直接用name_search传入context值限制范围 if self._context.has_key('account_id'): account_id = self._context.get('account_id') if account_id: domain = self._get_account_id_limit_domain(account_id) args += domain else: args = [('id', '=', -1)]@api.modeldef _get_account_id_limit_domain(self,account_id=None): # 通过科目上的业务伙伴限制domain值集 account = self.env['account.account'].browse(account_id) supplier = False customer = False employee = False domain = ['|', ('parent_id', '=', False), ('is_company', '=', True)] if account and account.partner_force_analytic: for record in account.partner_force_analytic: if record.code == 'supplier': supplier = True if record.code == 'customer': customer = True if record.code == 'employee': employee = True # 科目上业务伙伴值集domain拼接 domain += supplier and [('supplier', '=', True)] or [('supplier', '=', False)] domain += customer and [('customer', '=', True)] or [('customer', '=', False)] domain += supplier and [('employee', '=', True)] or [('employee', '=', False)] print domain return domain 参考文章]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ir_sequence序列]]></title>
    <url>%2Fbbs.github.io%2Fir-sequence%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[ir_sequence修改序列分析一下，系统中的序列ir.sequence最终还是使用的postgresql的sequence,我们可以通过查找pg_class,通过ir_sequence_(odoo的ir_sequence对应记录的id),12345678910举个例子,总账凭证序列号维护在公司的配置页签上: 1. 我们取到这个序列的ID: sequence_id = self.env[&apos;res.company&apos;].sequence.id 2. 拼接这个序列在pg_class中的序列记录名称: seq_name = &apos;ir_sequence_%03d&apos; % (sequence_id,) 3. 我们尝试着去修改对应的序列开始序号: next_number = 10 &quot;ALTER SEQUENCE %s RESTART WITH %d;&quot; % (seq_name,next_number)]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo-安装]]></title>
    <url>%2Fbbs.github.io%2FOdoo-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装Odoo10 - Windows - Install1.获取github源码，(github地址) 2.通过clone获取v10源代码git clone https://www.github.com/odoo/odoo –depth 1 –branch 10.0 –single-branch odoo10 安装底层应用依赖资源： 1234567891011121314151617181920212223242526272829303132331.安装python环境这里我们使用annacoda3(https://www.anaconda.com/download/#windows)，由于odoo10以上版本需要使用python3.x，所以我们使用conda指令创建python3.6虚拟环境 &apos;conda create -n py3od11 python=3.6&apos;2. 配置环境变量path(和python的一样 只不过需要配置的时创建的虚拟环境的路径 例如:D:\Anaconda3\envs\py3od11 和 D:\Anaconda3\envs\py3od11\Script)3. python改名 例如虚拟环境路径中：D:\Anaconda3\envs\py3od11 python.exe -&gt; python36.extpythonw.exe -&gt; pythonw36.ext 4. 安装基础必要插件 python36 -m pip install [package_name] Package_name包有如下: pypiwin32 Pillow-3.4.2-cp36-cp36m-win_amd64.whl gevent-1.2.2-cp36-cp36m-win_amd64.whl lxml-3.8.0-cp36-cp36m-win_amd64.whl psutil-5.3.1-cp36-cp36m-win_amd64.whl psycopg2-2.7.3-cp36-cp36m-win_amd64.whl pyldap-2.4.37-cp36-cp36m-win_amd64.whl reportlab-3.4.0-cp36-cp36m-win_amd64.whl 5. 安装odoo必要插件 切换到odoo目录下，你会发现有一个requirements.txt的文件，我们安装它内部的插件: python36 -m pip install -r requirements.txt python36 -m pip install -U werkzeug 安装必要的pdf打印插件 下载wkhtmltopdf 下载一个postgresql的navicat数据库管理软件. 下载并安装postgres10.对应pg的端口请配置好 例如(端口：5432 密码：123456)Postgres下载路径 7.在navicat中连接postgresql数据库. 8.在数据库中创建一个拥有createdb权限的用户 例如：user:odoo pwd:odoo 启动服务通过CMD切换到odoo的文件目录下，执行命令 python36 odoo-bin -s这样会在odoo的文件目录下生成一个odoo.conf的配置文件，我们只需要对文件进行配置修改. 安装完成运行时发现缺少一些关系包 虽然这些在requirements.txt包含，但是估计批量没安装成功 我们手动安装一下python36 -m pip install 包名 如：PyPDF2 passlib python-dateutil pywin32 PyYAML Pillow jinja2 html2text num2words等，运行时报错缺什么就装什么 为了启动能够连接到对应的数据库，我们需要修改对应的odoo.conf文件例如我修改后的配置文件:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[options]addons_path = D:\odoo11plus\odoo\odoo\addons,D:\odoo11plus\odoo\addonsadmin_passwd = handhandcsv_internal_sep = ,data_dir = D:\odoo11plus\data_dirdb_host = localhostdb_maxconn = 64db_name = Falsedb_password = odoodb_port = 5432db_sslmode = preferdb_template = template1db_user = odoodemo = &#123;&#125;email_from = Falsegeoip_database = /usr/share/GeoIP/GeoLite2-City.mmdbhttp_enable = Truehttp_interface = http_port = 8069import_partial = limit_memory_hard = Nonelimit_memory_soft = Nonelimit_request = Nonelimit_time_cpu = Nonelimit_time_real = Nonelimit_time_real_cron = Nonelist_db = Truelog_db = Falselog_db_level = warninglog_handler = :INFOlog_level = infologfile = Falselogrotate = Falselongpolling_port = 8072max_cron_threads = 2osv_memory_age_limit = 1.0osv_memory_count_limit = Falsepg_path = C:\Program Files\PostgreSQL\10\binpidfile = Falseproxy_mode = Falsereportgz = Falseserver_wide_modules = websmtp_password = Falsesmtp_port = 25smtp_server = localhostsmtp_ssl = Falsesmtp_user = Falsesyslog = Falsetest_commit = Falsetest_enable = Falsetest_file = Falsetest_report_directory = Falsetranslate_modules = [&apos;all&apos;]unaccent = Falsewithout_demo = Falseworkers = None 必须配置的有: admin_passwd、db_host、db_port、db_user、db_password、pg_path 其他的按情况配置. 12.为了工程化操作，我们可以在pycharm中直接创建一个启动项: 之后我们只需要在pycharm选择对应的启动服务，点击运行 就可以使用odoo服务了。 前台创建数据库并登入: 后记：写的粗糙，后期继续细化，另外如果把python的应用放到docker镜像中，在本地使用postgresql10的数据库服务，那样的开发应该是最适合的，以后补充。 Odoo12安装补充首先Odoo12采用的不再是less的css加载，而是node-sassc.pip3 install libsass Odoo安装叮嘱 模块上demo就算想使用demo文件，也配置了 结果安装后就是不生效:因为从前台创建数据库的时候]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitbook使用]]></title>
    <url>%2Fbbs.github.io%2FGitbook%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用说明文档安装流程 首先在你的本地需要如下软件： Git ① 、Gitbook Editor ② 下载安装完成后，选择一个对应的目录，获取对应书籍: 2.1 Windows获取方式： &emsp;&emsp;1. 选择一个适当的目录，鼠标点击右键，选择[] &emsp;&emsp;2. 输入：git clone https://rdc.hand-china.com/gitlab/13035/gitbook_test.git 2.2 Mac获取方式： &emsp;&emsp;打开终端，选择一个合适的目录，比如 /User/用户名/XXX,在终端执行： &emsp;&emsp;&emsp;&emsp; 1. cd /User/用户名/XX &emsp;&emsp;&emsp;&emsp; 2. git clone https://rdc.hand-china.com/gitlab/13035/gitbook_test.git &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 安装过程中可能需要输入账户/密码(工号/handhand) 使用流程 &emsp;&emsp;正在努力编写中… 资源&emsp;&emsp;①&emsp;Git下载地址 &emsp;&emsp;②&emsp;Gitbook Editor下载地址 &emsp;&emsp;&emsp;&emsp;上述连接如果下载速度慢请移步: &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Git-Windows64位 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Git-MacOS暂时未上传 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Gitbook Editor - Windows64位 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Gitbook Editor - MacOS位]]></content>
      <categories>
        <category>Gitbook</category>
      </categories>
      <tags>
        <tag>Gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu基础]]></title>
    <url>%2Fbbs.github.io%2FUbuntu%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[新安装ubuntu打开22端口12345678910ssh操作时出现： ...Connection failed. Type `help&apos; to learn how to use Xshell prompt.首先关闭ubuntu防火墙： sudo ufw disable然后安装OpenSSH: sudo apt-get install openssh-server openssh-client(如果没联网 首先处理网络连接)网络测试： netstat -tnl现在可以直接使用ssh连接了 Ubuntu vi/vim 上下左右删除按键转译成ABCD1234解决办法: echo &quot;set nocp&quot; &gt;&gt; ~/.vimrc source ~/.vimrc Ubuntu 换源123456789101112131415161718192021222324252627282930313233换成国内最快的阿里云源 第一步：备份原来的源文件 cd /etc/apt/ 然后会显示下面的源文件sources.list 输入命令 sudo cp sources.list sources.list.bak 就是将sources.list备份到sources.list.bak第二步：替换源 阿里云源的文件 vi sources.list 删除原内容，输入以下内容（输入之前换root权限，输入命令sudo su） deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # 源码 deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse ##测试版源 deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse # Canonical 合作伙伴和附加 deb http://archive.canonical.com/ubuntu/ xenial partner deb http://extras.ubuntu.com/ubuntu/ xenial main第三步：更新源和软件 sudo apt-get update 更新源 sudo apt-get upgrade 更新软件 Ubuntu TomcatTomcat卸载并安装]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo数据校验约束]]></title>
    <url>%2Fbbs.github.io%2FOdoo%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[Odoo的数据约束抛错可分为三种情况 手动判断约束(create/write) ORM层约束(api constrains) 数据库层约束(_sql_constrains) 从系统的执行优先级来看，顺序依次是 手动判断约束 -&gt; 数据库层约束 -&gt; ORM层约束 三种约束尽量不要同时使用，比如如果使用了手动判断约束，如果再添加了ORM层约束，通过ORM的search或者search_count方法搜出来的数据是包含当前正在创建并没有写入数据库的数据项。 1.手动约束：通过在model的create或者write方法中写条件判断，然后手动raise信息，这样可以控制抛错逻辑和抛错提示信息，比较常见。但需要注意的是，也许create/write的vals中需要校验的字段不一定是必输的，也就是说vals中可能缺失需要校验的值，这个一定好考虑到。 2.ORM层约束：通过写@api.constrains方法，来对数据库列进行进行判断，可以控制判断逻辑和抛错。但需要注意，如果新创建单据的话，这个地方通过ORM会搜索到新创建的记录对象，可能需求是校验唯一性，这样的话ORM方法来判断就不是适用了。而且只有单据执行create和write方法后，才能走此校验api. 3.数据库层约束：直接给数据库表添加约束条件，无论是前台还是后台创建数据都会被校验，缺点是不能不能自己写复杂的判断逻辑，而且抛错会抛系统的key重复错误之类的。 1-2抛错：3抛错：]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Odoo开发模板]]></title>
    <url>%2Fbbs.github.io%2FOdoo%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[基础model开发模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# -*- coding: utf-8 -*-#################################################################### 文件功能描述###################################################################from openerp import models, fields, api, _from openerp.exceptions import ValidationErrorimport openerp.addons.decimal_precision as dpfrom openerp.tools import float_compare&lt;!--more--&gt;class XXX(models.Model): """ 模型基本描述： XXX 详细描述： XXX 属性说明： XXX """ _name = 'XXX' _description = 'Model Description' # _rec_name = 'id' # Declaring Functions Begin # Declaring Functions End # 名称 name = fields.Char(string='Name', help='Name', default='/') # My Functions Begin @api.model def check_all(self, rec, vals, type, *args, **kwargs): """ 模型的通用校验方法 (ValidationError) :param rec: 记录对象 :param vals: create/write的数据字典，也可以是别的方法使用的字典 :param type: 区分检查逻辑块的标志 :param args: 动态浮动参数 :param kwargs: 动态指定参数 :return: 支持返回值,如果需要一定的返回值请自行写return """ if type == 'create': pass elif type == 'write': pass elif type == 'other1': pass # return XXX elif type == 'other2': pass else: pass # My Functions End # ORM Functions Begin @api.model def create(self, vals): # 当前的各种校验 self.check_all(rec=self, vals=vals, type='create') return super(XXX, self).create(vals) @api.multi def write(self, vals): for rec in self: # 当前的各种校验 self.check_all(rec=rec, vals=vals, type='write') return super(XXX, self).write(vals) @api.multi def unlink(self): for rec in self: pass return super(XXX, self).unlink() # ORM Functions End # Button Functions Begin # Button Functions End 基础XML视图开发模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;openerp&gt; &lt;data&gt; &lt;!--tree视图--&gt; &lt;record id="XXX_tree" model="ir.ui.view"&gt; &lt;field name="name"&gt;XXX_tree&lt;/field&gt; &lt;field name="model"&gt;XXX&lt;/field&gt; &lt;field name="arch" type="xml"&gt; &lt;tree&gt; &lt;field name="name"/&gt; &lt;/tree&gt; &lt;/field&gt; &lt;/record&gt; &lt;!--Form视图--&gt; &lt;record id="XXX_form" model="ir.ui.view"&gt; &lt;field name="name"&gt;XXX_form&lt;/field&gt; &lt;field name="model"&gt;XXX&lt;/field&gt; &lt;field name="arch" type="xml"&gt; &lt;form&gt; &lt;header&gt; &lt;!--&lt;button name="button_xxx" type="object" string="Button Name XXX"--&gt; &lt;!--class="oe_highlight" attrs="&#123;'invisible':[('state','not in',('created'))]&#125;"/&gt;--&gt; &lt;!--&lt;field name="state" widget="statusbar" statusbar_visible="created,done"/&gt;--&gt; &lt;/header&gt; &lt;sheet&gt; &lt;!--&lt;div class="oe_right"--&gt; &lt;!--style="width:30%;padding-top:15px;display:inline;height:58px;position:relative"--&gt; &lt;!--name="buttons"&gt;--&gt; &lt;!--界面跳转链接按钮--&gt; &lt;!--&lt;button type="object" style="position:absolute;right:80px" name="action_button_name_XXX"--&gt; &lt;!--class="oe_stat_button" icon="fa-credit-card"&gt;--&gt; &lt;!--链接单据数量 自己去py里写一个字段用compute形式动态计算--&gt; &lt;!--&lt;field name="num" string='Number' widget="statinfo"/&gt;--&gt; &lt;!--&lt;/button&gt;--&gt; &lt;!--&lt;/div&gt;--&gt; &lt;group&gt; &lt;group&gt; &lt;field name="name" invisible="1"/&gt; &lt;!--&lt;field name="Many2one_field"--&gt; &lt;!--attrs="&#123;'required':True,'readonly':[('state','!=','created')]&#125;"--&gt; &lt;!--options="&#123;'no_create_edit':'1','no_create':'1','no_open':'1'&#125;"/&gt;--&gt; &lt;/group&gt; &lt;group&gt; &lt;!-- ... --&gt; &lt;/group&gt; &lt;/group&gt; &lt;notebook&gt; &lt;page string="Page Name"&gt; &lt;field name="XXX_ids" options="&#123;'no_edit_no_open':True&#125;" attrs="&#123;'invisible':[('state','not in',('created'))]&#125;"&gt; &lt;tree editable="bottom/top" default_order="code" &gt; &lt;field name="code" /&gt; &lt;field name="name" /&gt; &lt;field name="xxx_id" options="&#123;'no_create_edit':'1','no_create':'1','no_open':'1'&#125;" attrs="&#123;'invisible':[('state','not in',('created'))]&#125;"/&gt; &lt;/tree&gt; &lt;/field&gt; &lt;/page&gt; &lt;!--&lt;page&gt;...&lt;/page&gt;--&gt; &lt;/notebook&gt; &lt;/sheet&gt; &lt;/form&gt; &lt;/field&gt; &lt;/record&gt; &lt;!--搜索视图--&gt; &lt;record id="XXX_search" model="ir.ui.view"&gt; &lt;field name="name"&gt;XXX_search&lt;/field&gt; &lt;field name="model"&gt;XXX&lt;/field&gt; &lt;field name="priority"&gt;10&lt;/field&gt; &lt;field name="arch" type="xml"&gt; &lt;search string="Search Name"&gt; &lt;field name="name"/&gt; &lt;filter name="XXX" icon="terp-camera_test" string="XXX" domain="[('XXX','=','XXX')]" help="XXX"/&gt;&lt;separator/&gt; &lt;group expand="0" string="Group By"&gt; &lt;filter string="XXX" icon="terp-folder-orange" domain="[]" context="&#123;'group_by':'fields_name_XXX'&#125;"/&gt; &lt;/group&gt; &lt;/search&gt; &lt;/field&gt; &lt;/record&gt; &lt;!--动作--&gt; &lt;record model="ir.actions.act_window" id="XXX_action"&gt; &lt;field name="name"&gt;XXX Action&lt;/field&gt; &lt;field name="res_model"&gt;XXX&lt;/field&gt; &lt;field name="view_type"&gt;form&lt;/field&gt; &lt;field name="view_mode"&gt;tree,form&lt;/field&gt; &lt;/record&gt; &lt;!--顶级菜单--&gt; &lt;menuitem id="top_XXX_menu" name="XXX" sequence="10" /&gt; &lt;!--二级菜单--&gt; &lt;menuitem id="XXX2_menu" name="XXX" parent="top_XXX_menu" sequence="10" /&gt; &lt;!--三级菜单--&gt; &lt;menuitem id="XXX3_menu" name="XXX3 Menu" parent="XXX2_menu" sequence="10" action="XXX_action"/&gt; &lt;/data&gt;&lt;/openerp&gt;]]></content>
      <categories>
        <category>Odoo</category>
      </categories>
      <tags>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fbbs.github.io%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建Github Page + Hexo博客系统]]></title>
    <url>%2Fbbs.github.io%2FHexo%2BGituhb%E9%A1%B5%E9%9D%A2%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[虽然网上有很多教程了，但是我还是想把自己的参考历程贴出来，给自己做一个参考 参考文档：使用Hexo+Github一步步搭建属于自己的博客（基础） 这里我只写简要的过程(Macbook Pro) 访问github创建一个新的博客仓库，仓库名称规格 XXX.github.io 提前安装好npm,使用npm安装hexo: npm install hexo -g 安装完成后，使用hexo -v检查是否安装成功 安装需要的组建 npm install 加载hexo: hexo g 启动访问服务: hexo s 通过http://localhost:4000访问本地Hexo博客(注意如果启动服务后，界面转圈，说明4000端口被占用，我们换4001端口尝试访问http://localhost:4001) 访问成功后，hexo绑定github page: git配置： git config –global user.name ‘Name’ git config –global user.email &#39;Mail@163.com‘ github 上传公钥(参考) 进入hexo的_config.yml文件绑定github page:滑动到文档末尾，添加： deploy: type: git repository: git@github.com:XXX/XXX.github.io.git(工程路径) branch: master 扩展一步上传博客内容到github仓库的组建：npm install hexo-deployer-git –save 创建博客：hexo new post “博客名称” 博客内容都在source/_post/目录中：同步更新到github page：hexo d -g 现在访问：https://github账户.github.io/博客工程名称/ 可能发现界面上的样式都失效了，因为我们没有定义_config的url： 1234url: https://XXX.github.io/XXX.github.io/root: /XXX.github.io/permalink: :year/:month/:day/:title/permalink_defaults: 再次访问后成功。 附： &emsp;&emsp;① _config参数说明 &emsp;&emsp;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
